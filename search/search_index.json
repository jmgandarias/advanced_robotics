{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"# Advanced Robotics  *Course material for the second part and Lab sesions of the Advanced Robotics course at [the University of M\u00e1laga](https://www.uma.es).*   By [Juan M. Gandarias](https://jmgandarias.com)   Systems Engineering and Automation Department  [Find out more...](./about/README.md)"},{"location":"about/","title":"Welcome","text":""},{"location":"about/#welcome","title":"Welcome","text":"<p>This is the home of the Advanced Robotics course: A fourth-year undergraduate course for Electronics, Robotics, and Mechatronics Engineering students in the School of Industrial Engineering at the University of M\u00e1laga. The lab course is developed by Dr Juan M. Gandarias, an Assistant Professor in the Systems Engineering and Automation Department.</p>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>The delivery of these materials following this format has been inspired by the work done by Dr. Tom Howard in the COM2009-3009 Robotics Course at The University of Sheffield. In addition, the content presented has been inspired by various sources listed below.</p>"},{"location":"about/changelog/","title":"Version History","text":""},{"location":"about/changelog/#iteration-1","title":"Iteration 1","text":"<p>Academic Year: 2024-2025</p> <ul> <li>Initial release of the curse.</li> <li>Course structured in 6 Lab sessions.</li> <li>Inclusion of the lab sessions.</li> </ul>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#license","title":"License","text":"<p> This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. </p> <p>You are free to distribute, remix, adapt, and build upon this work (for non-commercial purposes only) as long as credit is given to the original author.</p>"},{"location":"lab1/","title":"Lab 1: Cartesian trajectory planning","text":""},{"location":"lab1/#lab-1-cartesian-trajectory-planning","title":"Lab 1: Cartesian trajectory planning","text":"<p>This exercise illustrates the generation of Cartesian trajectories using one of the methodologies studied in this course. For this purpose, a series of functions will be used:</p>"},{"location":"lab1/#matlab-functions","title":"Matlab functions","text":"<ul> <li> <p><code>cartesian_planning</code>: Script that performs the complete simulation during all proposed segments, using the Robotic Toolbox with the ABB IRB120 manipulator model and the graphical representation of the temporal evolution of Cartesian trajectories and orientation in \\(ZYZ\\) Euler angles.</p> cartesian_planning.m<pre><code>% Lab 1: Cartesian trajectory planning\nclearvars\n\nP0=[1 0 0 0.3740; 0 1 0 0; 0 0 1 0.6300; 0 0 0 1];\nP1=[0 0 1 0.3038; 0 1 0 0; -1 0 0 0.0510; 0 0 0 1];\nP2=[0 -1 0 0; 0 0 1 0.3020; -1 0 0 0.5580; 0 0 0 1];\n\ntau=1;\nT=10;\n\n%% Exercise 1: Cartesian interpolation\n\n[p1, q1]=qpinter(P0, P1, 0)  %% (1)!\n[p2, q2]=qpinter(P0, P1, 1)\n\n%% Exercise 2: Smooth trajectory generation\n\n% Load ABB IRB120 model\n[IRB120, IRB120Data] = loadrobot('abbIrb120','DataFormat','row','Gravity',[0 0 -9.81]);\nHome=IRB120.homeConfiguration; % Use home position as start setting for inverser kinematics\n% Create object for inverse kinematics\nik_IRB120 = inverseKinematics('RigidBodyTree', IRB120); \n% Tolerances\nweights=[0.25 0.25 0.25 1 1 1];\n% Create figure to represent the manipulator\nf1=figure(1)\nset(f1,'Name','Manipulador');\n\n% Calculate the interpolation for the whole segment\nx=[]; y=[]; z=[]; alfa=[]; beta=[]; gamma=[];\nfor t=-T:0.1:T\n    % Call the function to generate the smoothed cartesian path\n    [P,Q]=generate_smooth_path(P0,P1,P2,tau,T,t); %% (2)!\n    x=[x P(1)];\n    y=[y P(2)];\n    z=[z P(3)];\n\n    Tq=q2tr(Q);\n    Tq(1:3,4)=[P(1) P(2) P(3)]'; % Complete homogeneous transofrmation matrix\n    ZYZ=tr2zyz(Tq);\n\n    alfa=[alfa,ZYZ(1)];\n    beta=[beta,ZYZ(2)];\n    gamma=[gamma,ZYZ(3)];\n\n    % Get position and orientation in joint space (ik)\n    [robot_pose, solnInfo]=ik_IRB120('tool0',Tq, weights, Home);\n    % Represent each configuration of the robot\n    ax=show(IRB120, robot_pose); axis([-0.5,0.5,-0.5,0.5,0,1]);   \n     hold on\n     plot3(ax, x, y, z, 'b*')  \n     hold off\n    drawnow\nend\n\n%% Exercise 3: Graphical representation\n\n% Represent cartesian position\nt=-T:0.1:T;\nf2=figure(2);\nset(f2,'Name','Cartesian position');\nsubplot(3,1,1),plot(t,x);title('X');xlabel('t [s]'); ylabel('position [m]');\nsubplot(3,1,2),plot(t,y);title('Y');xlabel('t [s]'); ylabel('position [m]');\nsubplot(3,1,3),plot(t,z);title('Z');xlabel('t [s]'); ylabel('position [m]');\n\n% Represent cartesian orientation as Euler angles\nf3=figure(3);\nset(f3,'Name','\u00c1ngulos de Euler');\nsubplot(3,1,1),plot(t,alfa);title('alfa');xlabel('t [s]'); ylabel('angle [rad]');\nsubplot(3,1,2),plot(t,beta);title('beta');xlabel('t [s]'); ylabel('angle [rad]');\nsubplot(3,1,3),plot(t,gamma);title('gamma');xlabel('t [s]'); ylabel('angle [rad]');\n</code></pre> <ol> <li>Here you call the function <code>qpinter</code> that you have to code in Exercise 1</li> <li>Here you call the function <code>generate_smooth_path</code> that you have to code in Exercise 2</li> </ol> </li> <li> <p><code>function [pr, qr]=qpinter(P1, P2, lambda)</code>: You have to code it. Explained in Exercise 2</p> qpinter.m<pre><code>function [pr,qr]=qpinter(Pa,Pb,t)\n\n    % Interpolate the position\n    pr = %% (1)!\n\n    % Interpolate the orientation \n    qr =  %% (2)!\n\nend\n</code></pre> <ol> <li>Compute the position interpolation.</li> <li>Compute the orientation interpolation</li> </ol> </li> <li> <p><code>function P=generate_smooth_path(P0, P1, P2, tau, T, t)</code>: You have to code it. Explained in Exercise 2</p> generate_smooth_path.m<pre><code>function [P, Q]=tramoq(P1, P2, P3, tau, T, t)\n    % Function that calculates the transformation (P - position, and Q - orientation) from P1 to P3 smoothing in P2 with Taylor method (quaternions)\n\n    if (t&lt;-T || t&gt;T)\n        % Out of allowed range\n        disp('Parameter t out of range');\n    else\n\n        if (t&lt;=-tau) % First segment (lineal)\n            %% (1)!\n        elseif (t&gt;=tau) % Third segment (lineal)\n            %% (2)!\n        else % Second segment (smoothing)\n            % Position interpolation\n            %% (3)!\n\n            % Orientation interpolation\n            %% (4)!\n        end\n\n    end\nend\n</code></pre> <ol> <li>Include the code for the first segment (from -t to T) using qpinter</li> <li>Include the code for the third segment (from T to t) using qpinter</li> <li>Include the code for the position smoothing in the second segment with Equation P(t)</li> <li>Include the code for the orientation smoothing in the second segment with Equation q(t)</li> </ol> </li> <li> <p><code>function T=zyz2tr(a)</code>: Converts the row vector \\(a=[\\alpha,\\beta,\\gamma]\\) of \\(ZYZ\\) Euler angles to a \\(4 \\times 4\\) homogeneous transformation \\(T\\).      Show function zyz2tr.m zyz2tr.m<pre><code>% function T=zyz2tr(a)\n%\n% Conversi\u00f3n del vector fila 'a' de angulos de Euler ZYZ a\n% transformaci\u00f3n homog\u00e9nea 'T' de 4x4\n%\n% V\u00edctor F. Mu\u00f1oz 2000\n\nfunction T=zyz2tr(a)\n\ns=sin(a); c=cos(a);\nT=[c(1)*c(2)*c(3)-s(1)*s(3)  -c(1)*c(2)*s(3)-s(1)*c(3)  c(1)*s(2)  0\n   s(1)*c(2)*c(3)+c(1)*s(3)  -s(1)*c(2)*s(3)+c(1)*c(3)  s(1)*s(2)  0\n       -s(2)*c(3)                   s(2)*s(3)             c(2)     0\n            0                           0                   0      1];\n</code></pre> </p> </li> <li> <p><code>function a=tr2zyz(T, m)</code>: Obtains the representation \\(a=[\\alpha,\\beta,\\gamma]\\) of the \\(ZYZ\\) Euler angles from the transformation \\(T\\). The sign of the parameter \\(m\\) chooses the solution. If not specified, the positive solution is taken by default.      Show function tr2zyz.m tr2zyz.m<pre><code>% function a=tr2zyz(T,m)\n%\n% Obtiene la representaci\u00f3n a=[alfa,beta,gamma] de los \u00e1ngulos de Euler ZYZ\n% de la transformaci\u00f3n T. El signo del par\ufffdmetro 'm' elige la solici\u00f3n. Si no\n% se especifica este, se toma por defecto la soluci\u00f3n positiva.\n%\n% V\u00edctor F. Mu\u00f1oz 2000\n\nfunction a=tr2zyz(T,m)\n\nif nargin==1, m=1; end\nM=sign(m);\n\nSbeta=M*sqrt(T(3,1)^2+T(3,2)^2);\nbeta=atan2(Sbeta,T(3,3));\nif abs(Sbeta)&gt;1e-3,\n    alfa=atan2(T(2,3)/Sbeta,T(1,3)/Sbeta);\n    gamma=atan2(T(3,2)/Sbeta,-T(3,1)/Sbeta);\nelse\n    alfa=0;\n    gamma=atan2(T(2,1),sign(T(3,3))*T(1,1));\n    warning('Configuraci\ufffdn degenerada');\nend\na=[alfa,beta,gamma];\n</code></pre> </p> </li> <li> <p><code>function q=tr2q(T, m)</code>: Converts the homogeneous matrix \\(T\\) to quaternion \\(q\\). The sign of \\(m\\) chooses the positive or negative solution. If \\(m\\) is omitted, the positive solution is taken by default.      Show function tr2q.m tr2q.m<pre><code>% function q=tr2q(T,m)\n%\n% Realiza la conversi\u00f3n a cuaternio q de la matriz homog\u00e9nea T. Las dos\n% soluciones se eligen mediante el par\u00e1metro m. El signo de  m elige la\n% soluci\u00f3n positiva o la negativa. Si m se omite se toma la positiva por defecto.\n%\n% V\u00edctor F. Mu\u00f1oz 2000\n\nfunction q=tr2q(T,m)\n\nif nargin==1, m=1; end\nM=sign(m);\nS=M*sqrt(T(1,1)+T(2,2)+T(3,3)+1)/2;\nif abs(S)&gt;1e-3,\n    X=(T(3,2)-T(2,3))/4/S;\n    Y=(T(1,3)-T(3,1))/4/S;\n    Z=(T(2,1)-T(1,2))/4/S;\nelse\n    S=0;\n    X=M*sqrt((T(1,1)+1)/2);\n    Y=M*sqrt((T(2,2)+1)/2);\n    Z=M*sqrt((T(3,3)+1)/2);\nend\nq=[S,X,Y,Z];\n</code></pre> </p> </li> <li> <p><code>function T=q2tr(q)</code>: Calculates the \\(4 \\times 4\\) homogeneous matrix \\(T\\) corresponding to the quaternion \\(q\\).      Show function q2tr.m q2tr.m<pre><code>% function T=q2tr(q)\n%\n% Calcula la matriz homog\u00e9nea T de dimensiones 4x4 correspondiente\n% al cuaternio q.\n%\n% V\u00edctor F. Mu\u00f1oz 2000\n\nfunction T=q2tr(q)\n\nS=q(1); X=q(2); Y=q(3); Z=q(4);\nT=[1-2*Y^2-2*Z^2    2*X*Y-2*S*Z     2*X*Z+2*S*Y   0\n    2*X*Y+2*S*Z    1-2*X^2-2*Z^2    2*Y*Z-2*S*X   0\n    2*X*Z-2*S*Y     2*Y*Z+2*S*X   1-2*X^2-2*Y^2   0\n          0              0               0        1];\n</code></pre> </p> </li> <li> <p><code>function q=qqmul(q1, q2)</code>: \\(q\\) is the quaternion resulting from multiplying \\(q_1\\) by \\(q_2\\). Both \\(q_1\\) and \\(q_2\\) must be two row vectors of four components. The result will also have the same format.      Show function qqmul.m qqmul.m<pre><code>% function q=qqmul(q1,q2)\n%\n% Multiplicaci\u00f3n de cuaternios. 'q' es el cuaternio resultado de multiplicar\n% q1 por q2. Tanto q1 como q2 deben ser dos vectores filas de cuatro componentes.\n% El resultando tambi\ufffdn tendr\ufffd el mismo formato.\n\nfunction q=qqmul(q1,q2)\n\nq=[q1(1)*q2(1)-q1(2:4)*q2(2:4)', ...\n   q2(1)*q1(2:4)+q1(1)*q2(2:4)+cross(q1(2:4),q2(2:4))];\n</code></pre> </p> </li> </ul>"},{"location":"lab1/#cartesian-interpolation","title":"Cartesian interpolation","text":"<p>Cartesian interpolation is characterized by achieving a linear variation of position and orientation, the latter uses the representation of orientation through quaternions. Therefore, when linking two rectilinear displacements, a velocity discontinuity occurs at the transition point.</p> <p>Figure 1 shows the described situation, using the example of concatenating a displacement from location \\(P_0\\) to \\(P_1\\) with another from \\(P_1\\) to \\(P_2\\). To avoid the velocity discontinuity that occurs at \\(P_1\\), a constant acceleration is used to adapt the velocity variation of vector \\(X\\) from the first segment to the second.</p> <p></p> <p>Figure 1. Diagram of the variation of position and velocity in the movement from \\(P_0\\) to \\(P_2\\) via \\(P_1\\).</p> <p>This way, \\(-\\tau\\) units of time before reaching \\(P_1\\) (time 0), the velocity will be linearly changed from \\(\\Delta P_1/T_1\\) to \\(\\Delta P_2/T_2\\), to accommodate the velocity \\(\\tau\\) units of time after passing \\(P_1\\). Thus, the problem is defined as the calculation of a quadratic function \\(X(t)\\) that starts at point \\(P_A\\) and ends at \\(P_B\\) (start and end points of the smoothing) defined in the time range \\([-\\tau, \\tau]\\).</p> <p>Applying the boundary conditions at both ends of the segment and defining the acceleration in the area, the position is obtained as:</p> <p> $$ P(t) = P_1 - \\frac{(\\tau - t)^2}{4\\tau T_1} \\Delta P_1 + \\frac{(\\tau + t)^2}{4\\tau T_2} \\Delta P_2 $$</p> <p>And the orientation as:</p> <p> $$ q(t) = q_1 \\cdot q \\left[ -\\frac{(\\tau - t)^2}{4\\tau T_1} \\theta_1, n_1 \\right] \\cdot q \\left[ \\frac{(\\tau + t)^2}{4\\tau T_2} \\theta_2, n_2 \\right] $$</p>"},{"location":"lab1/#exercises","title":"Exercises","text":"<p>Considering all the above, and the following values for \\(P_0, P_1, P_2\\), the following exercises are requested:</p> \\[ P_0 = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0.374 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0.63 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\\\ \\end{pmatrix}, \\quad P_1 = \\begin{pmatrix} 0 &amp; 1 &amp; 0 &amp; 0.3038 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -1 &amp; 0 &amp; 0 &amp; 0.051 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\\\ \\end{pmatrix}, \\quad P_2 = \\begin{pmatrix} 0 &amp; -1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0.302 \\\\ -1 &amp; 0 &amp; 0 &amp; 0.558 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{pmatrix} \\]"},{"location":"lab1/#1-quaternion-interpolation","title":"1. Quaternion interpolation","text":"<p>Define the quaternion interpolation function based on the Taylor method <code>[pr, qr]=qpinter(P1, P2, lambda)</code> that calculates the intermediate quaternion between \\(q_1\\) (initial) and \\(q_2\\) (final). The value \\(\\lambda\\) must satisfy \\(0\\leq \\lambda \\leq 1\\), so that <code>[p1, q1]=qpinter(P1, P2, 0)</code> and <code>[p2, q2]=qpinter(P1, P2, 1)</code>.</p>"},{"location":"lab1/#2-smooth-trajectory-generation","title":"2. Smooth trajectory generation","text":"<p>Create a MATLAB function in the format <code>P=generate_smooth_path(P0, P1, P2, tau, T, t)</code> that calculates the transformation \\(P\\) corresponding to the movement from \\(P_0\\) to \\(P_2\\) via \\(P_1\\) smoothed by the Taylor method. The parameters \\(\\tau\\) and \\(T\\) correspond respectively to the transition interval and total time used to traverse the path as shown in Figure 1, and \\(T\\) indicates the time at which the location of the calculated path \\(P\\) is reached.</p>"},{"location":"lab1/#3-graphical-representation","title":"3. Graphical representation","text":"<p>Plot the evolution of position and orientation (in ZYZ Euler angles) throughout the trajectory.</p>"},{"location":"lab1/#expected-results","title":"Expected results","text":"<p>The expected result is illustrated in the following video and figures:</p> <p></p> <p>Video 1. Expected result of the lab session.</p> <p></p> <p>Figure 2. Final configuration and smooth path.</p> <p></p> <p>Figure 3. Position trajectories.</p> <p></p> <p>Figure 4. Orientation trajectories.</p>"},{"location":"lab2/","title":"Lab 2: Manipulator dynamics simulation","text":""},{"location":"lab2/#lab-2-manipulator-dynamics-simulation","title":"Lab 2: Manipulator dynamics simulation","text":""},{"location":"lab2/#setup-ros2","title":"Setup ROS2","text":"<p>This lab session assumes you have ROS2 Humble installed in your computer.</p> <p>You'll also need to install the uma_environment_tools as it will install some important packages and libraries that we'll use in the course. In that repo, you'll find the required steps to install it.</p> <p>If you already have a native version of Ubuntu 22.04 installed, you can skip steps 1 and 2.</p>"},{"location":"lab2/#testing-the-uma-environment","title":"Testing the UMA environment","text":"<p>Once you have installed the UMA environment, you should see that everything is working correctly. If after installing it, you go to your catking workspace folder and when you run this alias</p> <pre><code>cb\n</code></pre> <p>you find an error like <code>'ROS colcon build is not installed'</code>, then you'll need to uninstall ros and install the environment again:</p> <pre><code>sudo apt remove ~nros-humble-* &amp;&amp; sudo apt autoremove\nsudo rm /etc/apt/sources.list.d/ros2.list\nsudo apt update\nsudo apt autoremove\n# Consider upgrading for packages previously shadowed.\nsudo apt upgrade\ncd ~/uma_environment_tools/scripts\n./install_uma_environment.sh\n</code></pre> <p>Then you'll ned to run </p> <pre><code>update_uma_environment\n</code></pre>"},{"location":"lab3/","title":"Lab Session 3: Manipulator dynamics compensation","text":"<p>TBD</p>"},{"location":"lab4/","title":"Lab Session 4: Impedance controller","text":"<p>TBD</p>"},{"location":"lab5/","title":"Lab Session 5: Admittance controller","text":"<p>TBD</p>"},{"location":"lab6/","title":"Lab Session 6: Force control with inner position loop","text":"<p>TBD</p>"}]}