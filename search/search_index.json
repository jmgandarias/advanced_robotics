{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"# Advanced Robotics  *Course material for the second part and Lab sesions of the Advanced Robotics course at [the University of M\u00e1laga](https://www.uma.es).*   By [Juan M. Gandarias](https://jmgandarias.com)   Systems Engineering and Automation Department  [Find out more...](./about/README.md)"},{"location":"about/","title":"Welcome","text":""},{"location":"about/#welcome","title":"Welcome","text":"<p>This is the home of the Advanced Robotics course: A fourth-year undergraduate course for Electronics, Robotics, and Mechatronics Engineering students in the School of Industrial Engineering at the University of M\u00e1laga. The lab course is developed by Dr Juan M. Gandarias, an Assistant Professor in the Systems Engineering and Automation Department.</p>"},{"location":"about/acknowledgements/","title":"Acknowledgements","text":"<p>The delivery of these materials following this format has been inspired by the work done by Dr. Tom Howard in the COM2009-3009 Robotics Course at The University of Sheffield. In addition, the content presented has been inspired by various sources listed below.</p>"},{"location":"about/changelog/","title":"Version History","text":""},{"location":"about/changelog/#iteration-1","title":"Iteration 1","text":"<p>Academic Year: 2024-2025</p> <ul> <li>Initial release of the curse.</li> <li>Course structured in 6 Lab sessions.</li> <li>Inclusion of the lab sessions.</li> </ul>"},{"location":"about/license/","title":"License","text":""},{"location":"about/license/#license","title":"License","text":"<p> This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. </p> <p>You are free to distribute, remix, adapt, and build upon this work (for non-commercial purposes only) as long as credit is given to the original author.</p>"},{"location":"lab1/","title":"Lab 1: Cartesian trajectory planning","text":""},{"location":"lab1/#lab-1-cartesian-trajectory-planning","title":"Lab 1: Cartesian trajectory planning","text":"<p>This exercise illustrates the generation of Cartesian trajectories using one of the methodologies studied in this course. For this purpose, a series of functions will be used:</p>"},{"location":"lab1/#matlab-functions","title":"Matlab functions","text":"<ul> <li> <p><code>cartesian_planning</code>: Script that performs the complete simulation during all proposed segments, using the Robotic Toolbox with the ABB IRB120 manipulator model and the graphical representation of the temporal evolution of Cartesian trajectories and orientation in \\(ZYZ\\) Euler angles.</p> cartesian_planning.m<pre><code>% Lab 1: Cartesian trajectory planning\nclearvars\n\nP0=[1 0 0 0.3740; 0 1 0 0; 0 0 1 0.6300; 0 0 0 1];\nP1=[0 0 1 0.3038; 0 1 0 0; -1 0 0 0.0510; 0 0 0 1];\nP2=[0 -1 0 0; 0 0 1 0.3020; -1 0 0 0.5580; 0 0 0 1];\n\ntau=1;\nT=10;\n\n%% Exercise 1: Cartesian interpolation\n\n[p0, q0]=qpinter(P0, P1, 0)  %% (1)!\n[p1, q1]=qpinter(P0, P1, 1)\n\n%% Exercise 2: Smooth trajectory generation\n\n% Load ABB IRB120 model\n[IRB120, IRB120Data] = loadrobot('abbIrb120','DataFormat','row','Gravity',[0 0 -9.81]);\nHome=IRB120.homeConfiguration; % Use home position as start setting for inverser kinematics\n% Create object for inverse kinematics\nik_IRB120 = inverseKinematics('RigidBodyTree', IRB120); \n% Tolerances\nweights=[0.25 0.25 0.25 1 1 1];\n% Create figure to represent the manipulator\nf1=figure(1)\nset(f1,'Name','Manipulador');\n\n% Calculate the interpolation for the whole segment\nx=[]; y=[]; z=[]; alfa=[]; beta=[]; gamma=[];\nfor t=-T:0.1:T\n    % Call the function to generate the smoothed cartesian path\n    [P,Q]=generate_smooth_path(P0,P1,P2,tau,T,t); %% (2)!\n    x=[x P(1)];\n    y=[y P(2)];\n    z=[z P(3)];\n\n    Tq=q2tr(Q);\n    Tq(1:3,4)=[P(1) P(2) P(3)]'; % Complete homogeneous transofrmation matrix\n    ZYZ=tr2zyz(Tq);\n\n    alfa=[alfa,ZYZ(1)];\n    beta=[beta,ZYZ(2)];\n    gamma=[gamma,ZYZ(3)];\n\n    % Get position and orientation in joint space (ik)\n    [robot_pose, solnInfo]=ik_IRB120('tool0',Tq, weights, Home);\n    % Represent each configuration of the robot\n    ax=show(IRB120, robot_pose); axis([-0.5,0.5,-0.5,0.5,0,1]);   \n     hold on\n     plot3(ax, x, y, z, 'b*')  \n     hold off\n    drawnow\nend\n\n%% Exercise 3: Graphical representation\n\n% Represent cartesian position\nt=-T:0.1:T;\nf2=figure(2);\nset(f2,'Name','Cartesian position');\nsubplot(3,1,1),plot(t,x);title('X');xlabel('t [s]'); ylabel('position [m]');\nsubplot(3,1,2),plot(t,y);title('Y');xlabel('t [s]'); ylabel('position [m]');\nsubplot(3,1,3),plot(t,z);title('Z');xlabel('t [s]'); ylabel('position [m]');\n\n% Represent cartesian orientation as Euler angles\nf3=figure(3);\nset(f3,'Name','\u00c1ngulos de Euler');\nsubplot(3,1,1),plot(t,alfa);title('alfa');xlabel('t [s]'); ylabel('angle [rad]');\nsubplot(3,1,2),plot(t,beta);title('beta');xlabel('t [s]'); ylabel('angle [rad]');\nsubplot(3,1,3),plot(t,gamma);title('gamma');xlabel('t [s]'); ylabel('angle [rad]');\n</code></pre> <ol> <li>Here you call the function <code>qpinter</code> that you have to code in Exercise 1</li> <li>Here you call the function <code>generate_smooth_path</code> that you have to code in Exercise 2</li> </ol> </li> <li> <p><code>function [pr, qr]=qpinter(P1, P2, lambda)</code>: You have to code it. Explained in Exercise 2</p> qpinter.m<pre><code>function [pr,qr]=qpinter(Pa,Pb,t)\n\n    % Interpolate the position\n    pr = %% (1)!\n\n    % Interpolate the orientation \n    qr =  %% (2)!\n\nend\n</code></pre> <ol> <li>Compute the position interpolation.</li> <li>Compute the orientation interpolation</li> </ol> </li> <li> <p><code>function P=generate_smooth_path(P0, P1, P2, tau, T, t)</code>: You have to code it. Explained in Exercise 2</p> generate_smooth_path.m<pre><code>function [P, Q]=generate_smooth_path(P1, P2, P3, tau, T, t)\n    % Function that calculates the transformation (P - position, and Q - orientation) from P1 to P3 smoothing in P2 with Taylor method (quaternions)\n\n    if (t&lt;-T || t&gt;T)\n        % Out of allowed range\n        disp('Parameter t out of range');\n    else\n\n        if (t&lt;=-tau) % First segment (lineal)\n            %% (1)!\n        elseif (t&gt;=tau) % Third segment (lineal)\n            %% (2)!\n        else % Second segment (smoothing)\n            % Position interpolation\n            %% (3)!\n\n            % Orientation interpolation\n            %% (4)!\n        end\n\n    end\nend\n</code></pre> <ol> <li>Include the code for the first segment (from -t to T) using qpinter</li> <li>Include the code for the third segment (from T to t) using qpinter</li> <li>Include the code for the position smoothing in the second segment with Equation P(t)</li> <li>Include the code for the orientation smoothing in the second segment with Equation q(t)</li> </ol> </li> <li> <p><code>function T=zyz2tr(a)</code>: Converts the row vector \\(a=[\\alpha,\\beta,\\gamma]\\) of \\(ZYZ\\) Euler angles to a \\(4 \\times 4\\) homogeneous transformation \\(T\\).      Show function zyz2tr.m zyz2tr.m<pre><code>% function T=zyz2tr(a)\n%\n% Conversi\u00f3n del vector fila 'a' de angulos de Euler ZYZ a\n% transformaci\u00f3n homog\u00e9nea 'T' de 4x4\n%\n% V\u00edctor F. Mu\u00f1oz 2000\n\nfunction T=zyz2tr(a)\n\ns=sin(a); c=cos(a);\nT=[c(1)*c(2)*c(3)-s(1)*s(3)  -c(1)*c(2)*s(3)-s(1)*c(3)  c(1)*s(2)  0\n   s(1)*c(2)*c(3)+c(1)*s(3)  -s(1)*c(2)*s(3)+c(1)*c(3)  s(1)*s(2)  0\n       -s(2)*c(3)                   s(2)*s(3)             c(2)     0\n            0                           0                   0      1];\n</code></pre> </p> </li> <li> <p><code>function a=tr2zyz(T, m)</code>: Obtains the representation \\(a=[\\alpha,\\beta,\\gamma]\\) of the \\(ZYZ\\) Euler angles from the transformation \\(T\\). The sign of the parameter \\(m\\) chooses the solution. If not specified, the positive solution is taken by default.      Show function tr2zyz.m tr2zyz.m<pre><code>% function a=tr2zyz(T,m)\n%\n% Obtiene la representaci\u00f3n a=[alfa,beta,gamma] de los \u00e1ngulos de Euler ZYZ\n% de la transformaci\u00f3n T. El signo del par\ufffdmetro 'm' elige la solici\u00f3n. Si no\n% se especifica este, se toma por defecto la soluci\u00f3n positiva.\n%\n% V\u00edctor F. Mu\u00f1oz 2000\n\nfunction a=tr2zyz(T,m)\n\nif nargin==1, m=1; end\nM=sign(m);\n\nSbeta=M*sqrt(T(3,1)^2+T(3,2)^2);\nbeta=atan2(Sbeta,T(3,3));\nif abs(Sbeta)&gt;1e-3,\n    alfa=atan2(T(2,3)/Sbeta,T(1,3)/Sbeta);\n    gamma=atan2(T(3,2)/Sbeta,-T(3,1)/Sbeta);\nelse\n    alfa=0;\n    gamma=atan2(T(2,1),sign(T(3,3))*T(1,1));\n    warning('Configuraci\ufffdn degenerada');\nend\na=[alfa,beta,gamma];\n</code></pre> </p> </li> <li> <p><code>function q=tr2q(T, m)</code>: Converts the homogeneous matrix \\(T\\) to quaternion \\(q\\). The sign of \\(m\\) chooses the positive or negative solution. If \\(m\\) is omitted, the positive solution is taken by default.      Show function tr2q.m tr2q.m<pre><code>% function q=tr2q(T,m)\n%\n% Realiza la conversi\u00f3n a cuaternio q de la matriz homog\u00e9nea T. Las dos\n% soluciones se eligen mediante el par\u00e1metro m. El signo de  m elige la\n% soluci\u00f3n positiva o la negativa. Si m se omite se toma la positiva por defecto.\n%\n% V\u00edctor F. Mu\u00f1oz 2000\n\nfunction q=tr2q(T,m)\n\nif nargin==1, m=1; end\nM=sign(m);\nS=M*sqrt(T(1,1)+T(2,2)+T(3,3)+1)/2;\nif abs(S)&gt;1e-3,\n    X=(T(3,2)-T(2,3))/4/S;\n    Y=(T(1,3)-T(3,1))/4/S;\n    Z=(T(2,1)-T(1,2))/4/S;\nelse\n    S=0;\n    X=M*sqrt((T(1,1)+1)/2);\n    Y=M*sqrt((T(2,2)+1)/2);\n    Z=M*sqrt((T(3,3)+1)/2);\nend\nq=[S,X,Y,Z];\n</code></pre> </p> </li> <li> <p><code>function T=q2tr(q)</code>: Calculates the \\(4 \\times 4\\) homogeneous matrix \\(T\\) corresponding to the quaternion \\(q\\).      Show function q2tr.m q2tr.m<pre><code>% function T=q2tr(q)\n%\n% Calcula la matriz homog\u00e9nea T de dimensiones 4x4 correspondiente\n% al cuaternio q.\n%\n% V\u00edctor F. Mu\u00f1oz 2000\n\nfunction T=q2tr(q)\n\nS=q(1); X=q(2); Y=q(3); Z=q(4);\nT=[1-2*Y^2-2*Z^2    2*X*Y-2*S*Z     2*X*Z+2*S*Y   0\n    2*X*Y+2*S*Z    1-2*X^2-2*Z^2    2*Y*Z-2*S*X   0\n    2*X*Z-2*S*Y     2*Y*Z+2*S*X   1-2*X^2-2*Y^2   0\n          0              0               0        1];\n</code></pre> </p> </li> <li> <p><code>function q=qqmul(q1, q2)</code>: \\(q\\) is the quaternion resulting from multiplying \\(q_1\\) by \\(q_2\\). Both \\(q_1\\) and \\(q_2\\) must be two row vectors of four components. The result will also have the same format.      Show function qqmul.m qqmul.m<pre><code>% function q=qqmul(q1,q2)\n%\n% Multiplicaci\u00f3n de cuaternios. 'q' es el cuaternio resultado de multiplicar\n% q1 por q2. Tanto q1 como q2 deben ser dos vectores filas de cuatro componentes.\n% El resultando tambi\ufffdn tendr\ufffd el mismo formato.\n\nfunction q=qqmul(q1,q2)\n\nq=[q1(1)*q2(1)-q1(2:4)*q2(2:4)', ...\n   q2(1)*q1(2:4)+q1(1)*q2(2:4)+cross(q1(2:4),q2(2:4))];\n</code></pre> </p> </li> <li> <p><code>function q2=qinv(q)</code>: \\(q_2\\) is the quaternion resulting from computing the inverse of \\(q\\).      Show function qinv.m qinv.m<pre><code>function q2=qinv(q)\n\n    q2=[q(1)/(sqrt(q(1)^2+q(2)^2+q(3)^2+q(4)^2)),...\n        -q(2:4)/(sqrt(q(1)^2+q(2)^2+q(3)^2+q(4)^2))];\n    end\n</code></pre> </p> </li> </ul>"},{"location":"lab1/#cartesian-interpolation","title":"Cartesian interpolation","text":"<p>Cartesian interpolation is characterized by achieving a linear variation of position and orientation, the latter uses the representation of orientation through quaternions. Therefore, when linking two rectilinear displacements, a velocity discontinuity occurs at the transition point.</p> <p>Figure 1 shows the described situation, using the example of concatenating a displacement from location \\(P_0\\) to \\(P_1\\) with another from \\(P_1\\) to \\(P_2\\). To avoid the velocity discontinuity that occurs at \\(P_1\\), a constant acceleration is used to adapt the velocity variation of vector \\(X\\) from the first segment to the second.</p> <p></p> <p>Figure 1. Diagram of the variation of position and velocity in the movement from \\(P_0\\) to \\(P_2\\) via \\(P_1\\).</p> <p>This way, \\(-\\tau\\) units of time before reaching \\(P_1\\) (time 0), the velocity will be linearly changed from \\(\\Delta P_1/T_1\\) to \\(\\Delta P_2/T_2\\), to accommodate the velocity \\(\\tau\\) units of time after passing \\(P_1\\). Thus, the problem is defined as the calculation of a quadratic function \\(X(t)\\) that starts at point \\(P_A\\) and ends at \\(P_B\\) (start and end points of the smoothing) defined in the time range \\([-\\tau, \\tau]\\).</p> <p>Applying the boundary conditions at both ends of the segment and defining the acceleration in the area, the position is obtained as:</p> <p> $$ \\mathbf{p}(t) = \\mathbf{p}_1 - \\frac{(\\tau - t)^2}{4\\tau T_1} \\Delta \\mathbf{p}_1 + \\frac{(\\tau + t)^2}{4\\tau T_2} \\Delta \\mathbf{p}_2 $$</p> <p>And the orientation as:</p> <p> $$ \\mathbf{q}(t) = \\mathbf{q}_1 \\cdot  \\mathbf{q} \\left[\\frac{-(\\tau - t)^2}{4\\tau T_1} \\theta_1, \\mathbf{n}_1 \\right] \\cdot \\mathbf{q} \\left[ \\frac{(\\tau + t)^2}{4\\tau T_2} \\theta_2, \\mathbf{n}_2 \\right] $$</p>"},{"location":"lab1/#exercises","title":"Exercises","text":"<p>Considering all the above, and the following values for \\(P_0, P_1, P_2\\), the following exercises are requested:</p> \\[ P_0 = \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0.374 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0.63 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\\\ \\end{bmatrix}, \\quad P_1 = \\begin{bmatrix} 0 &amp; 0 &amp; 1 &amp; 0.3038 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -1 &amp; 0 &amp; 0 &amp; 0.051 \\\\ 0 &amp; 0 &amp; 0 &amp; 1\\\\ \\end{bmatrix}, \\quad P_2 = \\begin{bmatrix} 0 &amp; -1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0.302 \\\\ -1 &amp; 0 &amp; 0 &amp; 0.558 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{bmatrix} \\]"},{"location":"lab1/#1-quaternion-interpolation","title":"1. Quaternion interpolation","text":"<p>Define the quaternion interpolation function based on the Taylor method <code>[pr, qr]=qpinter(P1, P2, lambda)</code> that calculates the intermediate quaternion between \\(q_1\\) (initial) and \\(q_2\\) (final). The value \\(\\lambda\\) must satisfy \\(0\\leq \\lambda \\leq 1\\), so that <code>[p1, q1]=qpinter(P1, P2, 0)</code> and <code>[p2, q2]=qpinter(P1, P2, 1)</code>.</p>"},{"location":"lab1/#2-smooth-trajectory-generation","title":"2. Smooth trajectory generation","text":"<p>Create a MATLAB function in the format <code>P=generate_smooth_path(P0, P1, P2, tau, T, t)</code> that calculates the transformation \\(P\\) corresponding to the movement from \\(P_0\\) to \\(P_2\\) via \\(P_1\\) smoothed by the Taylor method. The parameters \\(\\tau\\) and \\(T\\) correspond respectively to the transition interval and total time used to traverse the path as shown in Figure 1, and \\(T\\) indicates the time at which the location of the calculated path \\(P\\) is reached.</p>"},{"location":"lab1/#3-graphical-representation","title":"3. Graphical representation","text":"<p>Plot the evolution of position and orientation (in ZYZ Euler angles) throughout the trajectory.</p>"},{"location":"lab1/#expected-results","title":"Expected results","text":"<p>The expected result is illustrated in the following video and figures:</p> <p></p> <p>Video 1. Expected result of the lab session.</p> <p></p> <p>Figure 2. Final configuration and smooth path.</p> <p></p> <p>Figure 3. Position trajectories.</p> <p></p> <p>Figure 4. Orientation trajectories.</p>"},{"location":"lab2/","title":"Lab 2: Manipulator dynamics simulation","text":""},{"location":"lab2/#lab-2-manipulator-dynamics-simulation","title":"Lab 2: Manipulator dynamics simulation","text":""},{"location":"lab2/#1-setup-ros-2","title":"1. Setup ROS 2","text":"<p>For this lab session we will use ROS 2 Humble.</p> <p>You'll need to install the uma_environment_tools as it will install ROS2 Humble, and some important packages and libraries that we'll use in the course. In that repo, you'll find the required steps to install it.</p> <p>If you already have a native version of Ubuntu 22.04 installed, you can skip steps 1 and 2.</p> <p>A video of the installation, including the troubleshooting (if you don't find the errors, you don't need to run that part!) is shown below. Note that the video shows the installation with WSL. If you're using a native Ubuntu 22.04, you can skip the first instruction.</p> <p></p>"},{"location":"lab2/#11-testing-the-uma-environment","title":"1.1. Testing the UMA environment","text":"<p>Once you have installed the UMA environment, you should see that everything is working correctly.</p> <p>Try the following;</p> <pre><code>create_catkin_ws\n</code></pre> <p>Put the name <code>advanced_robotics_ws</code> to your workspace. </p> <p>If, after installing it, you go to your catkin workspace folder and when you run this alias</p> <pre><code>cb\n</code></pre> <p>you find an error like <code>'ROS colcon build is not installed'</code>, then you'll need to uninstall ros and install the environment again:</p> <pre><code>sudo apt remove ~nros-humble-* &amp;&amp; sudo apt autoremove\nsudo rm /etc/apt/sources.list.d/ros2.list\nsudo apt update\nsudo apt autoremove\n# Consider upgrading for packages previously shadowed.\nsudo apt upgrade\ncd ~/uma_environment_tools/scripts\n./install_uma_environment.sh\n</code></pre> <p>Then you'll ned to run</p> <pre><code>update_uma_environment\n</code></pre>"},{"location":"lab2/#2-install-uma-manipulator-package","title":"2. Install UMA manipulator package","text":"<p>You'll need to clone the <code>uma_arm_description</code> repository inside </p> <pre><code>cdw\ncd src\ngit clone https://github.com/jmgandarias/uma_arm_description.git\n</code></pre> <p>Warning</p> <p>This is a work-in-progress repository. Don't pay attention to the README.md file of that repo.</p> <p>Info</p> <p>You don't have to modify anything in this package. You just need it visualize the manipulator.</p> <p>Now, before compiling it, you'll need to install a series of dependencies:</p> <pre><code>sudo apt install ros-${ROS_DISTRO}-xacro\nsudo apt install ros-${ROS_DISTRO}-gazebo-ros-pkgs\nsudo  apt install ros-${ROS_DISTRO}-ros2-control ros-${ROS_DISTRO}-ros2-controllers ros-${ROS_DISTRO}-gazebo-ros2-control\nsudo apt-get install -y ros-${ROS_DISTRO}-joint-state-publisher-gui ros-${ROS_DISTRO}-rviz2\n</code></pre> <p>If you find an error trying to install these dependencies, most probably you'll need to update the packages repositories and upgrade them to the last version</p> <pre><code>sudo apt update\nsudo apt upgrade\n</code></pre> <p>Once the dependencies are correctly installed, you can compile the workspace</p> <pre><code>cdw\ncb\n</code></pre>"},{"location":"lab2/#21-test-the-uma-manipulator-package","title":"2.1. Test the UMA manipulator package","text":"<p>Open one terminal and run: </p><pre><code>ros2 launch uma_arm_description uma_arm_visualization.launch.py\n</code></pre> <p>You'll see RViz2 openning and showing the following:</p> <p></p> <p>You can open a new terminal and run the <code>joint_state_publisher_gui</code>to move joints of the robot</p> <pre><code>ros2 run joint_state_publisher_gui joint_state_publisher_gui \n</code></pre> <p>Tip</p> <p>If you press <code>ctrl + shift + o</code> or <code>ctrl + shift + e</code> in the terminator terminal, it will split the terminals vertically or horizontally </p> <p>Now, you should have the following in your terminals</p> <p></p> <p>A GUI should have opened now allowing you to manually drive the joints of the manipulator</p> <p></p> <p>Success</p> <p>Great work! Now you are ready to do the Lab session 2!</p> <p>You can also close all the terminals (press <code>ctrl + c</code>).</p>"},{"location":"lab2/#3-simulate-the-robot-dynamics","title":"3. Simulate the robot dynamics","text":"<p>The manipulator model you've loaded is purely a kinematic visualization (i.e., there is no dynamics - no forces, and there is no simulation)</p> <p>Info</p> <p>RViz 2 is 3D visualization tool, not a simulator. It means it allows you to see the robot models, sensor data, and other information shared in your ROS 2 environment in real-time and offers you a GUI to select the information to be visualize, but it is NOT a simulation</p> <p>There are different ways to simulate the dynamics. The (probably) most straightforard one is to use a simulator as Gazebo. However, as we are roboticists and want to see, touch, and learn the intrinsic effects of the dynamics of the robotic manipulator, we'll code the dynamics (the equations of motion) of the manipulator down into a node.</p>"},{"location":"lab2/#31-clone-the-uma_arm_control-package","title":"3.1. Clone the uma_arm_control package","text":"<p>To do this, we'll work with another package. You have to do the following</p> <pre><code>cdw\ncd src\ngit clone https://github.com/jmgandarias/uma_arm_control.git\n</code></pre> <p>Once you have done this, your workspace folder should look like this</p> <p></p> <p>Tip</p> <p>You can open the Ubuntu file manager even if you're using WSL running nautilus in a terminal </p><pre><code>nautilus\n</code></pre> <p>Now you can compile your workspace </p><pre><code>cdw\ncb\n</code></pre> <p>Success</p> <p>Great work! You're now ready to implement the manipulator dynamics</p> <p>But first, let's have a look at the <code>uma_arm_control</code> package distribution</p>"},{"location":"lab2/#32-understanding-the-uma_arm_control-package","title":"3.2. Understanding the uma_arm_control package","text":"<p>The package is structured as shown in the following image</p> <p></p> <p>Tip</p> <p>You can directly open VSCode inside WSL by running <code>code</code> in a terminal</p> <ul> <li> <p>config</p> <p>This folder contains configuration files that define various parameters. </p> <ul> <li>dynamics_params.yaml: This file contains parameters related to the dynamics of the robotic arm.  You need to modify it in this lab.</li> <li>impedance_params.yaml: This file includes parameters for the impedance controller.  You'll need to modify it in future sessions.</li> </ul> </li> <li> <p>launch</p> <p>This folder contains launch scripts.</p> <ul> <li>uma_arm_dynamics_launch.py: This Python script launches the dynamics simulation node for the robotic arm.  You don't have to modify it.</li> </ul> </li> <li> <p>src</p> <p>This folder contains the source code for the dynamics control and simulation of the robotic arm:</p> <ul> <li>uma_arm_dynamics.cpp: This C++ file contains the implementation of the dynamics equations (equations of motion) for the robotic arm.  You need to modify it in this lab.</li> </ul> </li> <li> <p>utils: This folder contains utility scripts that provide additional functionalities for the labs.  You don't have to modify it.</p> </li> <li>.gitignore: Specifies which files and directories should be ignored by Git version control.  You don't have to modify it.</li> <li>CMakeLists.txt: Contains instructions for building the project using CMake, a build system generator.  You'll need to modify it in future sessions.</li> <li>LICENSE: The license file that specifies the terms under which the project can be used and distributed.  You don't have to modify it.</li> <li>package.xml: Defines the package metadata for ROS, including dependencies and other information.  You don't have to modify it.</li> <li>README.md: Provides an overview of the project, instructions for setup, usage, and other relevant information.  You should modify it and keep it updated as you work on the lab sessions.</li> </ul>"},{"location":"lab2/#33-understanding-the-uma_arm_dynamicscpp-code","title":"3.3. Understanding the uma_arm_dynamics.cpp code","text":""},{"location":"lab2/#331-libraries","title":"3.3.1. Libraries","text":"<p>Includes the needed libraries. You don't have to modify it.</p> Show the code libraries.cpp<pre><code>    #include &lt;rclcpp/rclcpp.hpp&gt;\n    #include &lt;sensor_msgs/msg/joint_state.hpp&gt;\n    #include &lt;std_msgs/msg/float64_multi_array.hpp&gt;\n    #include &lt;geometry_msgs/msg/wrench.hpp&gt;\n    #include &lt;chrono&gt;\n    #include &lt;Eigen/Dense&gt;\n    #include &lt;cmath&gt;\n\n    using namespace std::chrono;\n</code></pre>"},{"location":"lab2/#332-constructor","title":"3.3.2. Constructor","text":"<p>ManipulatorDynamicsNode: Inherits from rclcpp::Node, making it a ROS 2 node. The class <code>ManipulatorDynamicsNode</code> is a ROS 2 node responsible for computing the dynamics of the manipulator (robot arm). You don't have to modify it.</p> <p>ManipulatorDynamicsNode(): Class constructor that Initializes the node with the name <code>manipulator_dynamics_node</code>.</p> Show the code constructor_initialization<pre><code>    class ManipulatorDynamicsNode : public rclcpp::Node\n    {\n    public:\n        ManipulatorDynamicsNode()\n            : Node(\"manipulator_dynamics_node\"),\n              joint_positions_(Eigen::VectorXd::Zero(2)),\n              joint_velocities_(Eigen::VectorXd::Zero(2)),\n              joint_accelerations_(Eigen::VectorXd::Zero(2)),\n              joint_torques_(Eigen::VectorXd::Zero(2)),\n              external_wrenches_(Eigen::VectorXd::Zero(2)),\n              previous_time_(high_resolution_clock::now())\n        {\n            // Frequency initialization\n            this-&gt;declare_parameter&lt;double&gt;(\"frequency\", 1000.0);\n\n            // Dynamics parameters initialization\n            this-&gt;declare_parameter&lt;double&gt;(\"m1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"m2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"l1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"l2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"b1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"b2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"g\", 9.81);\n            this-&gt;declare_parameter&lt;std::vector&lt;double&gt;&gt;(\"q0\", {0, 0});\n\n            // Get frequency [Hz] parameter and compute period [s]\n            double frequency = this-&gt;get_parameter(\"frequency\").as_double();\n\n            // Get dynamic parameters\n            m1_ = this-&gt;get_parameter(\"m1\").as_double();\n            m2_ = this-&gt;get_parameter(\"m2\").as_double();\n            l1_ = this-&gt;get_parameter(\"l1\").as_double();\n            l2_ = this-&gt;get_parameter(\"l2\").as_double();\n            g_ = this-&gt;get_parameter(\"g\").as_double();\n            b1_ = this-&gt;get_parameter(\"b1\").as_double();\n            b2_ = this-&gt;get_parameter(\"b2\").as_double();\n\n            // Set initial joint position\n            joint_positions_ = Eigen::VectorXd::Map(this-&gt;get_parameter(\"q0\").as_double_array().data(), 2);\n</code></pre> <p>Member variables initialization</p> <ul> <li><code>joint_positions_</code>, <code>joint_velocities_</code>, <code>joint_accelerations_</code>, <code>joint_torques_</code>, <code>external_wrenches_</code>: These are Eigen vectors initialized to zero. We'll use the library Eigen to work with vectors and matrices in C++.</li> <li><code>previous_time_</code>: Initialized to the current time using high_resolution_clock::now().</li> </ul> <p>Parameters declaration</p> <ul> <li><code>frequency</code>: The frequency at which the node operates (default 1000 Hz).</li> <li><code>m1</code>, <code>m2</code>: Masses of the manipulator's links.</li> <li><code>l1</code>, <code>l2</code>: Lengths of the manipulator's links.</li> <li><code>b1</code>, <code>b2</code>: Damping coefficients.</li> <li><code>g</code>: Gravitational acceleration.</li> <li><code>q0</code>: Initial joint positions.</li> </ul> <p>Parameters Retrieval</p> <ul> <li><code>get_parameter</code>: Retrieves the values of the declared parameters and assigns them to member variables. The values of the parameters are defined in the <code>dynamics_params.yaml</code> file inside the config folder.</li> </ul> <p>Setting Initial Joint Positions</p> <ul> <li><code>joint_positions_</code>: Sets the initial joint positions using the parameter q0.</li> </ul> Show the code constructor_publisher_subscriber<pre><code>     // Create subscription to joint_torques\n     joint_torques_subscription_ = this-&gt;create_subscription&lt;std_msgs::msg::Float64MultiArray&gt;(\n        \"joint_torques\", 1, std::bind(&amp;ManipulatorDynamicsNode::joint_torques_callback, this, std::placeholders::_1));\n\n    // Create subscription to external wrenches\n    external_wrenches_subscription_ = this-&gt;create_subscription&lt;geometry_msgs::msg::Wrench&gt;(\n        \"external_wrenches\", 1, std::bind(&amp;ManipulatorDynamicsNode::external_wrenches_callback, this, std::placeholders::_1));\n\n    // Create publisher for joint acceleration\n    publisher_acceleration_ = this-&gt;create_publisher&lt;std_msgs::msg::Float64MultiArray&gt;(\"joint_accelerations\", 1);\n\n    // Create publisher for joint state\n    publisher_joint_state_ = this-&gt;create_publisher&lt;sensor_msgs::msg::JointState&gt;(\"joint_states\", 1);\n\n    // Set the timer callback at a period (in milliseconds, multiply it by 1000)\n    timer_ = this-&gt;create_wall_timer(\n        std::chrono::milliseconds(static_cast&lt;int&gt;(1000 / frequency)), std::bind(&amp;ManipulatorDynamicsNode::timer_callback, this));\n    }\n</code></pre> <p>Subscriptions</p> <ul> <li><code>joint_torques_subscription_</code>: Subscribes to the <code>joint_torques</code> topic, which is expected to publish messages of type <code>std_msgs::msg::Float64MultiArray</code>. The callback function <code>joint_torques_callback</code> is bound to handle incoming messages.</li> <li><code>external_wrenches_subscription_</code>: Subscribes to the <code>external_wrenches</code> topic, which is expected to publish messages of type- <code>geometry_msgs::msg::Wrench</code>. The callback function <code>external_wrenches_callback</code> is bound to handle incoming messages.</li> </ul> <p>Publishers</p> <ul> <li><code>publisher_acceleration_</code>: Creates a publisher for the <code>joint_accelerations</code> topic, which will publish messages of type <code>std_msgs::msg::Float64MultiArray</code>.</li> <li><code>publisher_joint_state_</code>: Creates a publisher for the <code>joint_states</code> topic, which will publish messages of type <code>sensor_msgs::msg::JointState</code>.</li> </ul> <p>Timer</p> <ul> <li><code>timer_</code>: Sets up a timer that triggers the <code>timer_callback</code> function (explained below) at a period determined by the frequency parameter. The period is expected to be given in milliseconds, therefore, it is calculated as </li> </ul> \\[ period \\, \\text{[ms]} = \\frac{1 \\, [\\cancel{\\text{s}}] \\cdot 1000 \\, [\\text{ms}/\\cancel{\\text{s}}]}{frequency \\, [\\text{Hz}]}  \\]"},{"location":"lab2/#333-timer-callback","title":"3.3.3. Timer callback","text":"<p>The <code>timer_callback</code> function is responsible for:</p> <ul> <li>Calculating the <code>elapsed_time_</code> between callbacks.</li> <li>Updating the new <code>joint_accelerations_</code>, <code>joint_velocities_</code>, and <code>joint_positions_</code> using the respective functions (you'll need to implement these functions later).</li> <li>Publishing the updated joint states to the ROS topics.</li> </ul> <p>This function ensures that the manipulator's state is updated and communicated at regular intervals based on the timer's frequency.</p> Show the code timer_callback<pre><code>    // Timer callback - when there is a timer callback, computes the new joint acceleration, velocity and position and publishes them\n    void timer_callback()\n    {\n    // Get the actual elapsed time\n    auto current_time = high_resolution_clock::now();\n    elapsed_time_ = duration_cast&lt;duration&lt;double&gt;&gt;(current_time - previous_time_).count();\n    previous_time_ = current_time;\n\n    // Calculate JointState\n    joint_accelerations_ = calculate_acceleration();\n    joint_velocities_ = calculate_velocity();\n    joint_positions_ = calculate_position();\n\n    // Publish data\n    publish_data();\n    }\n</code></pre>"},{"location":"lab2/#334-topic-callbacks","title":"3.3.4. Topic callbacks","text":"<p>These callback functions ensure that the node's state is updated with the latest data from the subscribed topics. Specifically:</p> <ul> <li><code>joint_torques_callback</code>: Updates the <code>joint_torques_</code>  based on incoming messages.</li> <li><code>external_wrenches_callback</code>: Updates the <code>external_wrenches_</code> based on incoming messages.</li> </ul> Show the code topic_callbacks<pre><code>    private:\n        // Subscription callback - when a new message arrives, updates joint_torques_\n        void joint_torques_callback(const std_msgs::msg::Float64MultiArray::SharedPtr msg)\n        {\n            joint_torques_ = Eigen::VectorXd::Map(msg-&gt;data.data(), msg-&gt;data.size());\n        }\n\n        // Subscription callback - when a new message arrives, updates external_wrenches_\n        void external_wrenches_callback(const geometry_msgs::msg::Wrench::SharedPtr msg)\n        {\n            auto forces = msg-&gt;force;\n            external_wrenches_(0) = forces.x;\n            external_wrenches_(1) = forces.y;\n        }\n</code></pre>"},{"location":"lab2/#335-calculate-acceleration","title":"3.3.5. Calculate acceleration","text":"<p>This method computes the <code>joint_accelerations_</code> of the manipulator by considering the equations of motion, including inertia, Coriolis and centrifugal forces, friction, gravitational forces, and external torques. You have to implement it as explained later.</p> <p>At the moment, the method returns \\(\\mathbf{\\ddot{q}} = [0, 0]\\).</p> Show the code calculate_acceleration<pre><code>    // Method to calculate joint acceleration\n    Eigen::VectorXd calculate_acceleration()\n    {\n\n        // Initialize M, C, Fb, g_vec, J, and tau_ext\n\n        // Initialize q1, q2, q_dot1, and q_dot2\n\n        // Placeholder calculations for M, C, Fb, g, and tau_ext\n        // Calculate matrix M\n\n        // Calculate vector C (C is 2x1 because it already includes q_dot)\n\n        // Calculate Fb matrix\n\n        // Calculate g_vect\n\n        // Calculate J\n\n        // Calculate tau_ext\n\n        // Calculate joint accelerations using the dynamic model: q'' = M^(-1)[tau - C(q,q')q' - Fbq' - g(q) + tau_ext]\n        Eigen::VectorXd q_ddot(2);\n        q_ddot &lt;&lt; 0, 0;\n\n        // Return joint accelerations\n        return q_ddot;\n    }\n</code></pre>"},{"location":"lab2/#336-integrate-position-and-velocity","title":"3.3.6. Integrate position and velocity","text":"<p>This method computes the joint velocities and positions by integrating over the elapsed time. You have to implement it as explained later.</p> <p>At the moment, the methods return \\(\\mathbf{\\dot{q}} = \\mathbf{q} = [0, 0]\\).</p> Show the code Integrate_vel_pos<pre><code>     // Method to calculate joint velocity\n     Eigen::VectorXd calculate_velocity()\n     {\n         // Placeholder for velocity calculation\n         // Integrate velocity over the time step (elapsed_time_)\n         Eigen::VectorXd q_dot(2);\n         q_dot &lt;&lt; 0, 0;\n\n         return q_dot;\n     }\n\n     // Method to calculate joint position\n     Eigen::VectorXd calculate_position()\n     {\n         // Placeholder for position calculation\n         // Integrate position over the time step (elapsed_time_)\n         Eigen::VectorXd q(2);\n         q &lt;&lt; 0, 0;\n\n         return q;\n     }\n</code></pre>"},{"location":"lab2/#337-publish-the-data","title":"3.3.7. Publish the data","text":"<p>This method is responsible for publishing the computed <code>joint_accelerations_</code> and <code>joint_state</code> (<code>joint_positions_</code> and <code>joint_velocities_</code>) to their respective topics.</p> Show the code publish_data<pre><code>    // Method to publish the joint data\n    void publish_data()\n    {\n        // publish joint acceleration\n        auto acceleration_msg = std_msgs::msg::Float64MultiArray();\n        acceleration_msg.data.assign(joint_accelerations_.data(), joint_accelerations_.data() + joint_accelerations_.size());\n        publisher_acceleration_-&gt;publish(acceleration_msg);\n\n        // publish joint state\n        auto joint_state_msg = sensor_msgs::msg::JointState();\n        joint_state_msg.header.stamp = this-&gt;get_clock()-&gt;now();\n        joint_state_msg.name = {\"joint_1\", \"joint_2\"}; // Replace with actual joint names\n        joint_state_msg.position = {joint_positions_(0), joint_positions_(1)};\n        joint_state_msg.velocity = {joint_velocities_(0), joint_velocities_(1)};\n        publisher_joint_state_-&gt;publish(joint_state_msg);\n    }\n</code></pre>"},{"location":"lab2/#338-member-variables","title":"3.3.8. Member variables","text":"<p>Defines the member variables for the ManipulatorDynamicsNode class. Here's a detailed breakdown of these variables: Member Variables</p> Show the code member_variables<pre><code>    // Member variables\n        // Publishers and subscribers\n        rclcpp::Subscription&lt;std_msgs::msg::Float64MultiArray&gt;::SharedPtr joint_torques_subscription_;\n        rclcpp::Subscription&lt;geometry_msgs::msg::Wrench&gt;::SharedPtr external_wrenches_subscription_;\n        rclcpp::Publisher&lt;std_msgs::msg::Float64MultiArray&gt;::SharedPtr publisher_acceleration_;\n        rclcpp::Publisher&lt;sensor_msgs::msg::JointState&gt;::SharedPtr publisher_joint_state_;\n        rclcpp::TimerBase::SharedPtr timer_;\n\n        // Joint variables\n        Eigen::VectorXd joint_positions_;\n        Eigen::VectorXd joint_velocities_;\n        Eigen::VectorXd joint_accelerations_;\n        Eigen::VectorXd joint_torques_;\n        Eigen::VectorXd external_wrenches_;\n\n        // dynamic parameters variables\n        double m1_;\n        double m2_;\n        double l1_;\n        double l2_;\n        double b1_;\n        double b2_;\n        double g_;\n\n        // Variable to store the previous callback time and elapsed time\n        time_point&lt;high_resolution_clock&gt; previous_time_;\n        double elapsed_time_;\n    };\n</code></pre> <p>Publishers and Subscribers</p> <ul> <li><code>joint_torques_subscription_</code>: Subscription to the \"joint_torques\" topic.</li> <li><code>external_wrenches_subscription_</code>: Subscription to the \"external_wrenches\" topic.</li> <li><code>publisher_acceleration_</code>: Publisher for the \"joint_accelerations\" topic.</li> <li><code>publisher_joint_state_</code>: Publisher for the \"joint_states\" topic.</li> </ul> <p>Joint Variables</p> <ul> <li><code>joint_positions_</code>: Eigen vector representing the positions of the joints (\\(\\mathbf{q}\\)).</li> <li><code>joint_velocities_</code>: Eigen vector representing the velocities of the joints (\\(\\mathbf{\\dot{q}}\\)).</li> <li><code>joint_accelerations_</code>: Eigen vector representing the accelerations of the joints (\\(\\mathbf{\\ddot{q}}\\)).</li> <li><code>joint_torques_</code>: Eigen vector representing the torques applied to the joints (\\(\\boldsymbol{\\tau}\\)).</li> <li><code>external_wrenches_</code>: Eigen vector representing the external forces and torques applied to the EE (\\(\\mathbf{F}_{ext}\\)).</li> </ul> <p>Dynamic Parameters Variables</p> <ul> <li><code>m1_</code>: Mass of the first link of the manipulator.</li> <li><code>m2_</code>: Mass of the second link of the manipulator.</li> <li><code>l1_</code>: Length of the first link of the manipulator.</li> <li><code>l2_</code>: Length of the second link of the manipulator.</li> <li><code>b1_</code>: Damping coefficient for the first joint.</li> <li><code>b2_</code>: Damping coefficient for the second joint.</li> <li><code>g_</code>: Gravitational acceleration.</li> </ul> <p>Time Variables</p> <ul> <li><code>timer_</code>: Timer that triggers the timer_callback function at a specified frequency.</li> <li><code>previous_time_</code>: Stores the time of the previous callback execution.</li> <li><code>elapsed_time_</code>: Stores the elapsed time between the current and previous callback executions (\\(\\Delta t\\)).</li> </ul>"},{"location":"lab2/#339-main","title":"3.3.9. Main","text":"<p>Initializes the ROS 2 node, creates a shared pointer to an instance of the <code>ManipulatorDynamicsNode</code> class, keeps the node running, and shuts down the ROS 2 node when the node execution finishes.</p> Show the code main<pre><code>    int main(int argc, char *argv[])\n    {\n        rclcpp::init(argc, argv);\n        auto node = std::make_shared&lt;ManipulatorDynamicsNode&gt;();\n        rclcpp::spin(node);\n        rclcpp::shutdown();\n        return 0;\n    }\n</code></pre>"},{"location":"lab2/#34-implementing-the-dynamics-model","title":"3.4. Implementing the dynamics model","text":"<p>The dynamics of an open kinematic chain robotic manipulator is given by </p> \\[ \\mathbf{M}(\\mathbf{q}) \\ddot{\\mathbf{q}} + \\mathbf{C}(\\mathbf{q}, \\dot{\\mathbf{q}}) \\dot{\\mathbf{q}} +  \\mathbf{F}_b \\dot{\\mathbf{q}} + \\mathbf{g}(\\mathbf{q}) = \\boldsymbol{\\tau} + \\boldsymbol{\\tau}_{ext} \\] <p>where</p> <ul> <li>\\(\\mathbf{q} \\in \\mathbb{R}^{n \\times 1}\\) is the vector of joint positions (<code>joint_positions_</code>).</li> <li>\\(\\dot{\\mathbf{q}} \\in \\mathbb{R}^{n \\times 1}\\) is the vector of joint velocities (<code>joint_velocities_</code>).</li> <li>\\(\\ddot{\\mathbf{q}} \\in \\mathbb{R}^{n \\times 1}\\) is the vector of joint accelerations (<code>joint_accelerations_</code>).</li> <li>\\(\\mathbf{M}(\\mathbf{q}) \\in \\mathbb{R}^{n \\times n}\\) is the inertia matrix.</li> <li>\\(\\mathbf{C}(\\mathbf{q}, \\dot{\\mathbf{q}}) \\in \\mathbb{R}^{n \\times n}\\) is the Coriolis and centrifugal forces matrix.</li> <li>\\(\\mathbf{F}_b \\in \\mathbb{R}^{n \\times n}\\) is the viscous friction matrix.</li> <li>\\(\\mathbf{g} \\in \\mathbb{R}^{n \\times 1}\\) is the gravity vector.</li> <li>\\(\\boldsymbol{\\tau} \\in \\mathbb{R}^{n \\times 1}\\) is the vector of commanded joint torques (<code>joint_torques_</code>).</li> <li>\\(\\boldsymbol{\\tau}_{ext} \\in \\mathbb{R}^{n \\times 1}\\) is the vector of joint torques due to external forces.</li> </ul> <p>In our case, as we have a 2 DoF manipulator, \\(n=2\\).</p> <p>Hence, the acceleration due to applied torques is given by</p> \\[ \\ddot{\\mathbf{q}}  = \\mathbf{M}^{-1}(\\mathbf{q}) \\left[  \\boldsymbol{\\tau} + \\boldsymbol{\\tau}_{ext} - \\mathbf{C}(\\mathbf{q}, \\dot{\\mathbf{q}}) \\dot{\\mathbf{q}} - \\mathbf{F}_b \\dot{\\mathbf{q}} - \\mathbf{g}(\\mathbf{q}) \\right] \\] <p>To calculate the joint accelerations, we first need to compute the matrices. They can be computed applying the Lagrange or the Newton-Euler formulations. In our case, the matrices are defined by:</p> \\[ \\mathbf{M}(\\mathbf{q}) =\\begin{bmatrix} &amp; \\\\ m_1 \\cdot l_1^2 + m_2 \\cdot (l_1^2 + 2 \\cdot l_1 \\cdot l_2 \\cdot \\cos(q_2) + l_2^2) &amp; m_2 \\cdot (l_1 \\cdot l_2 \\cdot \\cos(q_2) + l_2^2) \\\\  m_2 \\cdot (l_1 \\cdot l_2 \\cdot \\cos(q_2) + l_2^2) &amp; m_2 \\cdot l_2^2\\\\ &amp; \\\\ \\end{bmatrix} \\] \\[ \\mathbf{C}(\\mathbf{q}, \\dot{\\mathbf{q}}) \\dot{\\mathbf{q}} = \\begin{bmatrix} &amp; \\\\ -m_2 \\cdot l_1 \\cdot l_2 \\cdot \\sin(q_2) \\cdot (2 \\cdot \\dot{q}_1 \\cdot \\dot{q}_2 +\\dot{q}_2^2) \\\\ m_2 \\cdot l_1 \\cdot l_2 \\cdot \\dot{q}_1^2 \\cdot \\sin(q_2)\\\\ &amp; \\\\ \\end{bmatrix} \\] \\[ \\mathbf{F}_b = \\begin{bmatrix} &amp; \\\\  b_1 &amp; 0\\\\ 0 &amp; b_2\\\\ &amp; \\\\ \\end{bmatrix} \\] \\[ \\mathbf{g}(\\mathbf{q}) = \\begin{bmatrix} &amp; \\\\ (m_1 + m_2) \\cdot l_1 \\cdot g_ \\cdot \\cos(q_1) + m_2 \\cdot g_ \\cdot l_2 \\cdot \\cos(q_1 + q_2) \\\\ m_2 \\cdot g \\cdot l_2 \\cdot \\cos(q_1 + q_2)\\\\ &amp; \\\\ \\end{bmatrix} \\] <p>We'll also need to compute the jacobian to include the external wrenches applied at the EE in our model</p> \\[ \\mathbf{J}(\\mathbf{q}) = \\begin{bmatrix} &amp; \\\\ -l_1 \\cdot \\sin(q_1) - l_2 \\cdot \\sin(q_1 + q_2) &amp; -l_2 \\cdot \\sin(q_1 + q_2) \\\\ l_1 \\cdot \\cos(q_1) + l_2 \\cdot \\cos(q_1 + q_2) &amp; l_2 \\cdot \\cos(q_1 + q_2)\\\\ &amp; \\\\ \\end{bmatrix} \\] <p>Then, we can calculate \\(\\boldsymbol{\\tau}_{ext}\\) as </p> \\[ \\boldsymbol{\\tau}_{ext} = \\mathbf{J}(\\mathbf{q})^T \\cdot \\mathbf{F}_{ext} \\] <p>We can now code them as</p> <pre><code>// Initialize M, C, Fb, g_vec, J, and tau_ext\nEigen::MatrixXd M(2, 2);\nEigen::VectorXd C(2);\nEigen::MatrixXd Fb(2, 2);\nEigen::VectorXd g_vec(2);\nEigen::MatrixXd J(2, 2);\nEigen::VectorXd tau_ext(2);\n\n// Initialize q1, q2, q_dot1, and q_dot2\ndouble q1 = joint_positions_(0);\ndouble q2 = joint_positions_(1);\ndouble q_dot1 = joint_velocities_(0);\ndouble q_dot2 = joint_velocities_(1);\n\n// Placeholder calculations for M, C, Fb, g, and tau_ext\n// Calculate matrix M\nM(0, 0) = m1_ * pow(l1_, 2) + m2_ * (pow(l1_, 2) + 2 * l1_ * l2_ * cos(q2) + pow(l2_, 2));\nM(0, 1) = m2_ * (l1_ * l2_ * cos(q2) + pow(l2_, 2));\nM(1, 0) = M(0, 1);\nM(1, 1) = m2_ * pow(l2_, 2);\n\n// Calculate vector C (C is 2x1 because it already includes q_dot)\nC &lt;&lt; -m2_ * l1_ * l2_ * sin(q2) * (2 * q_dot1 * q_dot2 + pow(q_dot2, 2)),\nm2_ * l1_ * l2_ * pow(q_dot1, 2) * sin(q2);\n\n// Calculate Fb matrix\nFb &lt;&lt; b1_, 0.0,\n0.0, b2_;\n\n// Calculate g_vect\ng_vec &lt;&lt; (m1_ + m2_) * l1_ * g_ * cos(q1) + m2_ * g_ * l2_ * cos(q1 + q2),\n    m2_ * g_ * l2_ * cos(q1 + q2);\n\n// Calculate J\nJ &lt;&lt; -l1_ * sin(q1) - l2_ * sin(q1 + q2), -l2_ * sin(q1 + q2),\n    l1_ * cos(q1) + l2_ * cos(q1 + q2), l2_ * cos(q1 + q2);\n\n// Calculate tau_ext\ntau_ext &lt;&lt; J.transpose() * external_wrenches_;\n\n// Calculate joint acceleration using the dynamic model: M * q_ddot = torque - C * q_dot - Fb * joint_velocities_ - g + tau_ext\nEigen::VectorXd q_ddot(2);\nq_ddot &lt;&lt; M.inverse() * (joint_torques_ - C - Fb * joint_velocities_ - g_vec + tau_ext);\n\nreturn q_ddot;\n</code></pre> <p>Tip</p> <p>I suggest you use VSCode and install the C/C++ Themes extension. Once installed, you can auto format the code (usually by pressing <code>ctrl + shift + i</code>)</p> <p>As we are implementing a discrete system:</p> \\[ \\ddot{\\mathbf{q}}_{k+1}  = \\mathbf{M}^{-1}(\\mathbf{q}_k) \\left[  \\boldsymbol{\\tau}_k + \\boldsymbol{\\tau}_{{ext}_k} - \\mathbf{C}(\\mathbf{q}_k, \\dot{\\mathbf{q}}_k) \\dot{\\mathbf{q}}_k - \\mathbf{F}_b \\dot{\\mathbf{q}}_k - \\mathbf{g}(\\mathbf{q}_k) \\right] \\] <p>we can get the joint velocities and position by discrete integration over time as</p> \\[ \\dot{\\mathbf{q}} = \\int \\ddot{\\mathbf{q}} \\, dt \\implies \\dot{\\mathbf{q}}_{k+1} = \\dot{\\mathbf{q}}_k + \\ddot{\\mathbf{q}}_{k+1} \\cdot \\Delta t \\] \\[ \\mathbf{q} = \\int \\dot{\\mathbf{q}} \\, dt \\implies \\mathbf{q}_{k+1} = \\mathbf{q}_k + \\dot{\\mathbf{q}}_{k+1} \\cdot \\Delta t \\] <p>We can now code them as</p> <pre><code>// Method to calculate joint velocity\nEigen::VectorXd calculate_velocity()\n{\n    // Placeholder for velocity calculation\n    // Integrate velocity over the time step (elapsed_time_)\n    Eigen::VectorXd q_dot = joint_velocities_ + joint_accelerations_ * elapsed_time_;\n\n    return q_dot;\n}\n\n// Method to calculate joint position\nEigen::VectorXd calculate_position()\n{\n    // Placeholder for position calculation\n    // Integrate position over the time step (elapsed_time_)\n    Eigen::VectorXd q = joint_positions_ + joint_velocities_ * elapsed_time_;\n\n    return q;\n}\n</code></pre>"},{"location":"lab2/#4-launch-the-dynamics-simulator-node","title":"4. Launch the dynamics simulator node","text":"<p>Once you have coded the dynamics, open a terminal and compile it:</p> <pre><code>cdw\ncb\n</code></pre> <p>Success</p> <p>Great! You've coded the manipulator dynamics and are now ready to launch the node to see how they work.</p> <p>First, you'll need to launch the UMA manipulator (step 2.1.).</p> <p>Hence, you will need to open 2 terminals and launch the following:</p>"},{"location":"lab2/#terminal-1","title":"Terminal 1","text":"<p>Launch the UMA manipulator model <code>uma_arm_visualization.launch.py</code>:</p> <pre><code>ros2 launch uma_arm_description uma_arm_visualization.launch.py\n</code></pre>"},{"location":"lab2/#terminal-2","title":"Terminal 2","text":"<p>Launch the dynamics model <code>uma_arm_dynamics_launch.py</code>:</p> <pre><code>ros2 launch uma_arm_control uma_arm_dynamics_launch.py\n</code></pre> <p>Hence, you should see the following</p> <p></p> <p>And the result of the simulation is</p> <p></p> <p>Tip</p> <ul> <li>Note that the order when launching the scripts is important. You should first launch the <code>uma_arm_visualization</code>. By doing this, the robot model is loaded but it doesn't do anything until there's a message published in the topic <code>/joint_state</code>. </li> <li>Then you can launch the <code>uma_arm_dynamics</code>. This is what the dynamics model does: Computes the dynamic model, and publishes the joint state to update the visualization. Note also that the dynamics node doesn't need the uma_arm_visualization to work. If you only launch the dynamics, they're computed without showing them in the uma_arm_visualization. If you run the visualization after launching the </li> </ul> <p>You can see the interaction between topics and nodes by openning another terminal and running</p> <pre><code>rqt_graph\n</code></pre> <p>You have to select the option <code>Node/Topics (all)</code> and then update the graph.</p> <p></p>"},{"location":"lab2/#5-graphical-representation","title":"5. Graphical representation","text":"<p>As robotics engineers, just seeing things work isn't enough for us. We want to understand how they work and be able to measure every parameter. One of the best ways to record the data of an experiment in ROS is to use ros bags.</p> <p>To record the data of the experiment, you can do the following:</p> <ol> <li> <p>If you want to be organized, you can create an experiments folder to store the data there:</p> <pre><code>cd\nmkdir experiments\n</code></pre> </li> <li> <p>Open a terminal and start the rosbag recording:</p> <pre><code>cd\ncd experiments\nros2 bag record --all -o experiment1\nros2 bag record --all\n</code></pre> </li> <li> <p>Open another terminal and launch the UMA manipulator model:</p> <pre><code>ros2 launch uma_arm_description uma_arm_visualization.launch.py\n</code></pre> </li> <li> <p>Open another terminal and launch the dynamics model <code>uma_arm_dynamics_launch.py</code>:</p> <pre><code>ros2 launch uma_arm_control uma_arm_dynamics_launch.py\n</code></pre> </li> </ol> <p>When the experiment is finished (let's say, after around 15 seconds - when the manipulator is more or less steady) you can stop it by cancel the recording and killing the nodes. </p> <p>To represent time series of data in ROS 2, the uma_environment has installed the tool plotjuggler. You can find more information on how to use plotjuggler in this video.</p> <p>You can run it by using the correspongind UMA environment alias</p> <pre><code>plotjuggler\n</code></pre> <p>Inside plotjuggler, and following the steps in the previous video, you can play the recorded rosbag.  If you use the layout in pos_vel_acc_layout.xml, you can plot the joint position, velocities, and accelerations.</p> <p></p> <p>Question</p> <p>What are the effects of modifying the dynamics parameters of the arm?</p> <p>You can modify some of the following parameters inside the <code>dynamics_params.yaml</code>: <code>m1</code>, <code>m2</code>, <code>b1</code>, <code>b2</code>, and <code>g</code>. Run different experiments and plot the data to see the effects of those parameters.</p> <p>Note that you only need to modify those inside <code>uma_arm_dynamics</code>. </p>"},{"location":"lab2/#optional-nice-plots-and-vector-images","title":"Optional - Nice plots and vector images","text":"<p>Plotjuggler is an excellent tool to visualize ROS topics data, and it also gives you some options to manipulate the data. However, sometimes you'll like to use a more powerful tool to manipulate the data such as matlab or python (with matplotlib).</p> <p>Plotjuggler allows you to save the data in csv format. This way, you can easily import the data with your preferred software to plot it. Below is an expample:</p> <ol> <li> <p>Click on the CSV exporter and export the data (export the data range into a file).</p> <p></p> </li> <li> <p>Go to matlab, open the CSV file and select the data you want to get. In the figure below you can see how I select the time stamp (column A), and the joint position data of joint 1 (column F) and joint 2 (column H). Don't forget to exclude the rows with uninmportable cells. Then, select Import selection as Generate Script to generate a script that  </p> <p></p> </li> <li> <p>You'll probably need to modify that script to change CSV location or the name of the variable that will store your data.</p> </li> <li> <p>Repeat these steps as much as you need it to get the data you want to plot. Here I give you the matlab scripts to get the joint, velocity, and acceleration data, respectively. </p> <ul> <li>get_position_data.m</li> <li>get_velocity_data.m</li> <li>get_acceleration_data.m</li> </ul> </li> <li> <p>Once you have the data in matlab, you can manipulate it the way you want. For example, you can create nicer plots with the units and names in the axes. Here I give you the script to create a nice plot with the experiment data.</p> <ul> <li>plot_resutls.m</li> </ul> </li> <li> <p>You can also export the figures in a vectorial graphic format such as PDF to have the best resolution possible, such as this one:</p> <p></p> </li> </ol> <p>An alternative to this is to directly use the ROS toolbox in Matlab to get the rosbag recorded data. But I'd rather export it with PlotJuggler.</p>"},{"location":"lab3/","title":"Lab Session 3: Inverse Dynamics Control","text":""},{"location":"lab3/#lab-session-3-inverse-dynamics-control","title":"Lab Session 3: Inverse Dynamics Control","text":"<p>In this lab session you will learn how to implement inverse dynamics controllers to compensate the non-linear dynamics of the manipulator to let you impose a specific  desired dynamic behavior of the manipulator. Note that you are expected to have finished the previous lab session as you'll need that implementation. </p>"},{"location":"lab3/#31-gravity-compensation","title":"3.1. Gravity compensation","text":""},{"location":"lab3/#311-implementation","title":"3.1.1. Implementation","text":"<p>As you could have noticed in the previous lab, the gravitational effects on the manipulator makes it to \"fall\". Hence, our controller should include these effects when computing the joint torques that will be commanded to the actuators. The simplest inverse dynamics controller is the gravity compensation controller that set the torques of the actuators to be equal to those produced by gravity </p> \\[ \\boldsymbol{\\tau} = \\mathbf{g}(\\mathbf{q}) \\] <p>To implement the gravity compensation controller you need to do the following:</p> <ol> <li> <p>Create the gravity compensation node: <code>gravity_compensation.cpp</code></p> <p> Show the code gravity_compensation.cpp<pre><code>    /*\n\n    Author: Juan M. Gandarias (http://jmgandarias.com)\n    email: jmgandarias@uma.es\n\n    This script calculates the torque to cancellate the gracvity dynamic effects\n\n    tau = g(q)\n\n    Inputs: desired_joint_accelerations, joint_state(joint_positions, joint_velocities)\n\n    Output: joint_torques\n\n    */\n\n    #include &lt;rclcpp/rclcpp.hpp&gt;\n    #include &lt;sensor_msgs/msg/joint_state.hpp&gt;\n    #include &lt;std_msgs/msg/float64_multi_array.hpp&gt;\n    #include &lt;chrono&gt;\n    #include &lt;Eigen/Dense&gt;\n    #include &lt;cmath&gt;\n\n    class DynamicsCancellationNode : public rclcpp::Node\n    {\n    public:\n        DynamicsCancellationNode()\n            : Node(\"gravity_compensation_node\"),\n              joint_positions_(Eigen::VectorXd::Zero(2)),\n              joint_torques_(Eigen::VectorXd::Zero(2))\n        {\n            // Frequency initialization\n            this-&gt;declare_parameter&lt;double&gt;(\"frequency\", 1000.0);\n\n            // Dynamics parameters initialization\n            this-&gt;declare_parameter&lt;double&gt;(\"m2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"m1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"l1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"l2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"b1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"b2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"g\", 9.81);\n            this-&gt;declare_parameter&lt;std::vector&lt;double&gt;&gt;(\"q0\", {0, 0});\n\n            // Get frequency [Hz] parameter and compute period [s]\n            double frequency = this-&gt;get_parameter(\"frequency\").as_double();\n\n            // Get dynamic parameters\n            m1_ = this-&gt;get_parameter(\"m1\").as_double();\n            m2_ = this-&gt;get_parameter(\"m2\").as_double();\n            l1_ = this-&gt;get_parameter(\"l1\").as_double();\n            l2_ = this-&gt;get_parameter(\"l2\").as_double();\n            g_ = this-&gt;get_parameter(\"g\").as_double();\n            b1_ = this-&gt;get_parameter(\"b1\").as_double();\n            b2_ = this-&gt;get_parameter(\"b2\").as_double();\n\n            // Set initial joint state\n            joint_positions_ = Eigen::VectorXd::Map(this-&gt;get_parameter(\"q0\").as_double_array().data(), 2);\n\n            // Create subscription to joint_torques\n            subscription_joint_states_ = this-&gt;create_subscription&lt;sensor_msgs::msg::JointState&gt;(\n                \"joint_states\", 1, std::bind(&amp;DynamicsCancellationNode::joint_states_callback, this, std::placeholders::_1));\n\n            // Create publishers for joint torque\n            publisher_joint_torques_ = this-&gt;create_publisher&lt;std_msgs::msg::Float64MultiArray&gt;(\"joint_torques\", 1);\n\n            // Set the timer callback at a period (in milliseconds, multiply it by 1000)\n            timer_ = this-&gt;create_wall_timer(\n                std::chrono::milliseconds(static_cast&lt;int&gt;(1000 / frequency)), std::bind(&amp;DynamicsCancellationNode::timer_callback, this));\n        }\n\n        // Timer callback - when there is a timer callback, computes the new joint acceleration, velocity and position and publishes them\n        void timer_callback()\n        {\n            // Calculate torque to cancel the dynamic effects\n            joint_torques_ = gravity_compensation();\n\n            // Publish data\n            publish_data();\n        }\n\n    private:\n        // joint_states subscription callback - when a new message arrives, updates the dynamics cancellation and publishes teh joint_torques_\n        void joint_states_callback(const sensor_msgs::msg::JointState::SharedPtr msg)\n        {\n\n            // Assuming the joint names are \"joint_1\" and \"joint_2\"\n            auto joint1_index = std::find(msg-&gt;name.begin(), msg-&gt;name.end(), \"joint_1\") - msg-&gt;name.begin();\n            auto joint2_index = std::find(msg-&gt;name.begin(), msg-&gt;name.end(), \"joint_2\") - msg-&gt;name.begin();\n\n            if (static_cast&lt;std::vector&lt;std::string&gt;::size_type&gt;(joint1_index) &lt; msg-&gt;name.size() &amp;&amp; \n                static_cast&lt;std::vector&lt;std::string&gt;::size_type&gt;(joint2_index) &lt; msg-&gt;name.size())\n            {\n                joint_positions_(0) = msg-&gt;position[joint1_index];\n                joint_positions_(1) = msg-&gt;position[joint2_index];\n            }\n        }\n\n        // Method to calculate the desired joint torques\n        Eigen::VectorXd gravity_compensation()\n        {\n            // Placeholder for calculate the commanded torques\n            // Calculate the control torque to compensate only for gravity effects: tau = g(q)\n\n            // Calculate g_vect\n\n            // // Calculate desired torque\n            Eigen::VectorXd torque(2);\n            torque &lt;&lt; 0, 0;\n\n            return torque;\n        }\n\n        // Method to publish the joint data\n        void publish_data()\n        {\n            // publish joint torque\n            auto joint_torques_msg = std_msgs::msg::Float64MultiArray();\n            joint_torques_msg.data.assign(joint_torques_.data(), joint_torques_.data() + joint_torques_.size());\n            publisher_joint_torques_-&gt;publish(joint_torques_msg);\n        }\n\n        // Member variables\n        // Publishers and subscribers\n        rclcpp::Subscription&lt;sensor_msgs::msg::JointState&gt;::SharedPtr subscription_joint_states_;\n        rclcpp::Publisher&lt;std_msgs::msg::Float64MultiArray&gt;::SharedPtr publisher_joint_torques_;\n        rclcpp::TimerBase::SharedPtr timer_;\n\n        // Joint variables\n        Eigen::VectorXd joint_positions_;\n        Eigen::VectorXd joint_torques_;\n\n        // dynamic parameters variables\n        double m1_;\n        double m2_;\n        double l1_;\n        double l2_;\n        double b1_;\n        double b2_;\n        double g_;\n\n    };\n\n    int main(int argc, char *argv[])\n    {\n        rclcpp::init(argc, argv);\n        auto node = std::make_shared&lt;DynamicsCancellationNode&gt;();\n        rclcpp::spin(node);\n        rclcpp::shutdown();\n        return 0;\n    }\n</code></pre> </p> </li> <li> <p>You need to program the method <code>gravity_compensation()</code> to calculate de desired torques.     </p><pre><code>// Method to calculate the desired joint torques\nEigen::VectorXd gravity_compensation()\n{\n    // Placeholder for calculate the commanded torques\n    // Calculate the control torque to compensate only for gravity effects: tau = g(q)\n\n    // Calculate g_vect\n\n    // // Calculate desired torque\n    Eigen::VectorXd torque(2);\n    torque &lt;&lt; 0, 0;\n\n    return torque;\n}\n</code></pre> </li> <li>Create the <code>gravity_compensation_launch.py</code> file (you need to do this in order to get the dynamic pameters from the config file). You don't need to do any modification in this file, just include it inside the launch folder.      Show the code gravity_compensation_launch.py<pre><code>    import os\n    from launch import LaunchDescription\n    from launch_ros.actions import Node\n    from ament_index_python.packages import get_package_share_directory\n\n    def generate_launch_description():\n        config = os.path.join(\n            get_package_share_directory('uma_arm_control'),\n            'config',\n            'dynamics_params.yaml'\n        )\n\n        gravity_compensation_node = Node(\n                package='uma_arm_control',\n                executable='gravity_compensation',\n                name='gravity_compensation',\n                output='screen',\n                parameters=[config]\n            )\n\n        return LaunchDescription([gravity_compensation_node])\n</code></pre> </li> <li>Modify the <code>CMakeLists.txt</code> to include the new node      Show the code CMakeLists.txt<pre><code>    #   Author: Juan M. Gandarias (http://jmgandarias.com)\n    #   email: jmgandarias@uma.es\n\n    cmake_minimum_required(VERSION 3.8)\n    project(uma_arm_control)\n\n    if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n      add_compile_options(-Wall -Wextra -Wpedantic)\n    endif()\n\n    # find dependencies\n    find_package(ament_cmake REQUIRED)\n    find_package(rclcpp REQUIRED)\n    find_package(std_msgs REQUIRED)\n    find_package(geometry_msgs REQUIRED)\n    find_package(sensor_msgs REQUIRED)\n    find_package(Eigen3 REQUIRED)\n\n    include_directories(${EIGEN3_INCLUDE_DIR})\n\n    ## COMPILE\n    add_executable(uma_arm_dynamics src/uma_arm_dynamics.cpp)\n    add_executable(gravity_compensation src/gravity_compensation.cpp)\n\n    ament_target_dependencies(uma_arm_dynamics \n      rclcpp\n      std_msgs\n      sensor_msgs\n      geometry_msgs\n      Eigen3\n    )\n\n    ament_target_dependencies(gravity_compensation \n      rclcpp\n      std_msgs\n      sensor_msgs\n      Eigen3\n    )\n\n    if(BUILD_TESTING)\n      find_package(ament_lint_auto REQUIRED)\n      # the following line skips the linter which checks for copyrights\n      # comment the line when a copyright and license is added to all source files\n      set(ament_cmake_copyright_FOUND TRUE)\n      # the following line skips cpplint (only works in a git repo)\n      # comment the line when this package is in a git repo and when\n      # a copyright and license is added to all source files\n      set(ament_cmake_cpplint_FOUND TRUE)\n      ament_lint_auto_find_test_dependencies()\n    endif()\n\n    install(TARGETS uma_arm_dynamics gravity_compensation\n      DESTINATION lib/${PROJECT_NAME}\n      )\n\n    install(DIRECTORY \n      launch\n      config\n      DESTINATION share/${PROJECT_NAME}/\n    )\n\n    ament_package()\n</code></pre> </li> <li> <p>Once you have done this, the uma_arm_control package should look like this:</p> <p></p> </li> <li> <p>Now, you can compile the workspace     </p><pre><code>cdw\ncb\n</code></pre> </li> </ol>"},{"location":"lab3/#312-launch-the-controller","title":"3.1.2. Launch the controller","text":"<p>To launch the controller you'll need to do the following:</p> <ol> <li>Open one terminal and launch the uma_arm_visualization.</li> <li>Open another terminal and launch the controller.</li> <li>Open another terminal and launch the dynamics model</li> </ol> <p></p> <p>If you run the <code>rqt_graph</code> you should see how the gravity compensation node is getting the <code>joint_state</code> and feeding the manipulator with the computed torques</p> <p></p> <p>As a result, now the manipulator stays in the initial position defined by \\(\\mathbf{q}_0 = [45^o, -45^o]\\) (note that the initial position is defined by <code>q0</code> in the <code>dynamics_params.yaml</code>config file).</p> <p></p>"},{"location":"lab3/#313-simulating-the-force-sensor","title":"3.1.3. Simulating the force sensor","text":"<p>As we don't have a proper simulator where we could attach a simulated F/T sensor to the robot EE and apply forces against virtual objects, what we can do is to virtually apply forces to the EE of the robot. We can do this because, in the previous lab, we inmplemented considered the dynamics effects of external wrenches applied to the EE in the robot dynamics model.</p> \\[ \\boldsymbol{\\tau}_{ext} = \\mathbf{J}(\\mathbf{q})^T \\cdot \\mathbf{F}_{ext} \\] <p>Hence, we can simulate an F/T sensor with a node that publishes virtual wrenches. To do this, you can use the <code>wrench_trackbar_publisher.py</code> utility included in the <code>uma_control</code> package.</p> Show the code wrench_trackbar_publisher.py<pre><code>    import rclpy\n    from rclpy.node import Node\n    from geometry_msgs.msg import Wrench\n    import tkinter as tk\n    from threading import Thread\n    import time\n\n    class WrenchTrackbarPublisher(Node):\n        def __init__(self):\n            super().__init__('wrench_trackbar_publisher')\n            self.publisher_ = self.create_publisher(Wrench, 'external_wrenches', 10)\n            self.force_x = 0.0\n            self.force_y = 0.0\n            self.force_z = 0.0\n            self.torque_x = 0.0\n            self.torque_y = 0.0\n            self.torque_z = 0.0\n            self.continuous_mode = True\n\n            self.root = tk.Tk()\n            self.root.title(\"Wrench Publisher\")\n\n            self.create_trackbar('Force X', -30.0, 30.0, self.update_force_x)\n            self.create_trackbar('Force Y', -30.0, 30.0, self.update_force_y)\n            self.create_trackbar('Force Z', -30.0, 30.0, self.update_force_z)\n            self.create_trackbar('Torque X', -10.0, 10.0, self.update_torque_x)\n            self.create_trackbar('Torque Y', -10.0, 10.0, self.update_torque_y)\n            self.create_trackbar('Torque Z', -10.0, 10.0, self.update_torque_z)\n\n            self.mode_button = tk.Button(self.root, text=\"Switch to Instantaneous Mode\", command=self.switch_mode)\n            self.mode_button.pack()\n\n            center_button = tk.Button(self.root, text=\"Center All\", command=self.center_all)\n            center_button.pack()\n\n            # Start the publishing thread\n            self.publish_thread = Thread(target=self.publish_wrench_continuously)\n            self.publish_thread.start()\n\n        def create_trackbar(self, label, min_val, max_val, callback):\n            frame = tk.Frame(self.root)\n            frame.pack()\n            tk.Label(frame, text=f\"{min_val}\").pack(side=tk.LEFT)\n            trackbar = tk.Scale(frame, label=label, from_=min_val, to=max_val, orient=tk.HORIZONTAL, command=callback, resolution=0.1, length=400, sliderlength=30)\n            trackbar.pack(side=tk.LEFT)\n            trackbar.bind(\"&lt;ButtonRelease-1&gt;\", lambda event, lbl=label: self.reset_slider(lbl))\n            tk.Label(frame, text=f\"{max_val}\").pack(side=tk.LEFT)\n\n        def update_force_x(self, value):\n            self.force_x = float(value)\n\n        def update_force_y(self, value):\n            self.force_y = float(value)\n\n        def update_force_z(self, value):\n            self.force_z = float(value)\n\n        def update_torque_x(self, value):\n            self.torque_x = float(value)\n\n        def update_torque_y(self, value):\n            self.torque_y = float(value)\n\n        def update_torque_z(self, value):\n            self.torque_z = float(value)\n\n        def reset_slider(self, label):\n            if not self.continuous_mode:\n                for widget in self.root.winfo_children():\n                    if isinstance(widget, tk.Frame):\n                        for child in widget.winfo_children():\n                            if isinstance(child, tk.Scale) and child.cget(\"label\") == label:\n                                child.set(0.0)\n\n        def switch_mode(self):\n            self.continuous_mode = not self.continuous_mode\n            mode_text = \"Switch to Continuous Mode\" if not self.continuous_mode else \"Switch to Instantaneous Mode\"\n            self.mode_button.config(text=mode_text)\n\n        def center_all(self):\n            for widget in self.root.winfo_children():\n                if isinstance(widget, tk.Frame):\n                    for child in widget.winfo_children():\n                        if isinstance(child, tk.Scale):\n                            child.set(0.0)\n\n        def publish_wrench_continuously(self):\n            while rclpy.ok():\n                msg = Wrench()\n                msg.force.x = self.force_x\n                msg.force.y = self.force_y\n                msg.force.z = self.force_z\n                msg.torque.x = self.torque_x\n                msg.torque.y = self.torque_y\n                msg.torque.z = self.torque_z\n                self.publisher_.publish(msg)\n                time.sleep(0.001)  # Sleep for 1 millisecond (1 kHz frequency)\n\n        def run(self):\n            self.root.mainloop()\n\n    def main(args=None):\n        rclpy.init(args=args)\n        node = WrenchTrackbarPublisher()\n        try:\n            node.run()\n        except KeyboardInterrupt:\n            pass\n        finally:\n            node.destroy_node()\n            rclpy.shutdown()\n\n    if __name__ == '__main__':\n        main()\n</code></pre> <p>Note that you don't have to change anything in that script. You can run it by openning a terminal and running the following:</p> <pre><code>cdw\ncd src/uma_arm_control/utils\npython3 wrench_trackbar_publisher.py\n</code></pre> <p>Once you have done this, you'll see a GUI that allows you to publish virtual forces and torques. Note that, as our robot has only 2 DoFs and the dynamics model considers only the 2D XY plane, only forces applied at the X and Y axes will have an effect on our robot. This GUI has two operation modes: The continuous mode and the instantaneuos mode. You can see how they work in this video:</p> <p></p> <p>Launch the dynamics model and the gravity compensation controller and apply virtual forces. Your rqt_graph should then look like this:</p> <p></p> <p>Question</p> <p>What is the behavior of the robot when you apply virtual forces to the EE? Use videos and/or plots to support your answer.</p>"},{"location":"lab3/#32-linearization-by-inverse-dynamics-control","title":"3.2. Linearization by inverse dynamics control","text":""},{"location":"lab3/#321-implementation","title":"3.2.1. Implementation","text":"<p>Now, we can compensate the whole non-linear dynamics of the manipulator by feedback linearization. This way, we'll theoretically be able to force the manipulator to achieve a desired dynamics behavior without being affected by their own dynamics (note that this is only true when the dynamics model perfectly matches the manipulator dynamics, which won't happen in the real world). </p> <p>To do this, you need to implement the following control schema</p> <p></p> <p>Then, we need to create a node that computes the non-linear dynamics cancellation based on the desired joint accelerations (\\(\\ddot{\\mathbf{q}}_d\\)) and the current joint state (\\(\\mathbf{q}, \\dot{\\mathbf{q}}\\)). Then, the commanded joint torques computed with the inverse dynamics controller are given by</p> \\[ \\boldsymbol{\\tau} = \\mathbf{M}(\\mathbf{q}) \\cdot \\ddot{\\mathbf{q}}_d + \\underbrace{\\mathbf{C} (\\mathbf{q}, \\dot{\\mathbf{q}}) \\cdot \\dot{\\mathbf{q}} + \\mathbf{F}_b \\cdot \\dot{\\mathbf{q}} + \\mathbf{g}}_{\\mathbf{n}(\\mathbf{q}, \\dot{\\mathbf{q}})} \\] <p>To implement the inverse dynamics controller you need to do the following:</p> <ol> <li>Create the inverse dynamics cancellation node: <code>dynamics_cancellation.cpp</code></li> </ol> Show the code dynamics_cancellation.cpp<pre><code>    /*\n\n    Author: Juan M. Gandarias (http://jmgandarias.com)\n    email: jmgandarias@uma.es\n\n\n    This script cancellate the manipulator dynamics with feedback linearization\n\n    tau = M(q)*q'' + n(q,q')\n\n    with n(q,q') = C(q,q')q' + Fb q' + g(q)\n\n    Inputs: desired_joint_accelerations, joint_state(joint_positions, joint_velocities)\n\n    Output: joint_torques\n\n\n    */\n\n    #include &lt;rclcpp/rclcpp.hpp&gt;\n    #include &lt;sensor_msgs/msg/joint_state.hpp&gt;\n    #include &lt;std_msgs/msg/float64_multi_array.hpp&gt;\n    #include &lt;geometry_msgs/msg/wrench.hpp&gt;\n    #include &lt;chrono&gt;\n    #include &lt;Eigen/Dense&gt;\n    #include &lt;cmath&gt;\n\n    class DynamicsCancellationNode : public rclcpp::Node\n    {\n    public:\n        DynamicsCancellationNode()\n            : Node(\"dynamics_cancellation_node\"),\n              joint_positions_(Eigen::VectorXd::Zero(2)),\n              joint_velocities_(Eigen::VectorXd::Zero(2)),\n              desired_joint_accelerations_(Eigen::VectorXd::Zero(2)),\n              joint_torques_(Eigen::VectorXd::Zero(2))\n        {\n            // Frequency initialization\n            this-&gt;declare_parameter&lt;double&gt;(\"frequency\", 1000.0);\n\n            // Dynamics parameters initialization\n            this-&gt;declare_parameter&lt;double&gt;(\"m2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"m1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"l1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"l2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"b1\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"b2\", 1.0);\n            this-&gt;declare_parameter&lt;double&gt;(\"g\", 9.81);\n            this-&gt;declare_parameter&lt;std::vector&lt;double&gt;&gt;(\"q0\", {0, 0});\n\n            // Get frequency [Hz] parameter and compute period [s]\n            double frequency = this-&gt;get_parameter(\"frequency\").as_double();\n\n            // Get dynamic parameters\n            m1_ = this-&gt;get_parameter(\"m1\").as_double();\n            m2_ = this-&gt;get_parameter(\"m2\").as_double();\n            l1_ = this-&gt;get_parameter(\"l1\").as_double();\n            l2_ = this-&gt;get_parameter(\"l2\").as_double();\n            g_ = this-&gt;get_parameter(\"g\").as_double();\n            b1_ = this-&gt;get_parameter(\"b1\").as_double();\n            b2_ = this-&gt;get_parameter(\"b2\").as_double();\n\n            // Set initial joint state\n            joint_positions_ = Eigen::VectorXd::Map(this-&gt;get_parameter(\"q0\").as_double_array().data(), 2);\n\n            // Create subscription to joint_states\n            subscription_joint_states_ = this-&gt;create_subscription&lt;sensor_msgs::msg::JointState&gt;(\n                \"joint_states\", 1, std::bind(&amp;DynamicsCancellationNode::joint_states_callback, this, std::placeholders::_1));\n\n            // Create subscription to joint_accelerations\n            subscription_desired_joint_accelerations_ = this-&gt;create_subscription&lt;std_msgs::msg::Float64MultiArray&gt;(\n                \"desired_joint_accelerations\", 1, std::bind(&amp;DynamicsCancellationNode::desired_joint_accelerations_callback, this, std::placeholders::_1));\n\n            // Create publishers for joint torque\n            publisher_joint_torques_ = this-&gt;create_publisher&lt;std_msgs::msg::Float64MultiArray&gt;(\"joint_torques\", 1);\n\n            // Set the timer callback at a period (in milliseconds, multiply it by 1000)\n            timer_ = this-&gt;create_wall_timer(\n                std::chrono::milliseconds(static_cast&lt;int&gt;(1000 / frequency)), std::bind(&amp;DynamicsCancellationNode::timer_callback, this));\n        }\n\n        // Timer callback - when there is a timer callback, computes the new joint acceleration, velocity and position and publishes them\n        void timer_callback()\n        {\n            // Calculate torque to cancel the dynamic effects\n            joint_torques_ = cancel_dynamics();\n\n            // Publish data\n            publish_data();\n        }\n\n    private:\n        // joint_states subscription callback - when a new message arrives, updates the dynamics cancellation and publishes teh joint_torques_\n        void joint_states_callback(const sensor_msgs::msg::JointState::SharedPtr msg)\n        {\n\n            // Assuming the joint names are \"joint_1\" and \"joint_2\"\n            auto joint1_index = std::find(msg-&gt;name.begin(), msg-&gt;name.end(), \"joint_1\") - msg-&gt;name.begin();\n            auto joint2_index = std::find(msg-&gt;name.begin(), msg-&gt;name.end(), \"joint_2\") - msg-&gt;name.begin();\n\n            if (static_cast&lt;std::vector&lt;std::string&gt;::size_type&gt;(joint1_index) &lt; msg-&gt;name.size() &amp;&amp;\n                static_cast&lt;std::vector&lt;std::string&gt;::size_type&gt;(joint2_index) &lt; msg-&gt;name.size())\n            {\n                joint_positions_(0) = msg-&gt;position[joint1_index];\n                joint_positions_(1) = msg-&gt;position[joint2_index];\n                joint_velocities_(0) = msg-&gt;velocity[joint1_index];\n                joint_velocities_(1) = msg-&gt;velocity[joint2_index];\n            }\n        }\n\n        // joint_states subscription callback - when a msg arrives, updates desired_joint_accelerations_\n        void desired_joint_accelerations_callback(const std_msgs::msg::Float64MultiArray::SharedPtr msg)\n        {\n            desired_joint_accelerations_ = Eigen::VectorXd::Map(msg-&gt;data.data(), msg-&gt;data.size());\n        }\n\n        // Method to calculate joint acceleration\n        Eigen::VectorXd cancel_dynamics()\n        {\n            // Initialize M, C, Fb, g_vec, and tau_ext\n\n            // Initialize q1, q2, q_dot1, and q_dot2\n\n            // Calculate matrix M\n\n            // Calculate vector C (C is 2x1 because it already includes q_dot)\n\n            // Calculate Fb matrix\n\n            // Calculate g_vect\n\n            // Calculate control torque using the dynamic model: torque = M * q_ddot + C * q_dot + Fb * q_dot + g\n            Eigen::VectorXd torque(2);\n            torque &lt;&lt; 0, 0;\n\n            return torque;\n        }\n\n        // Method to publish the joint data\n        void publish_data()\n        {\n            // publish joint torque\n            auto joint_torques_msg = std_msgs::msg::Float64MultiArray();\n            joint_torques_msg.data.assign(joint_torques_.data(), joint_torques_.data() + joint_torques_.size());\n            publisher_joint_torques_-&gt;publish(joint_torques_msg);\n        }\n\n        // Member variables\n        // Publishers and subscribers\n        rclcpp::Subscription&lt;sensor_msgs::msg::JointState&gt;::SharedPtr subscription_joint_states_;\n        rclcpp::Subscription&lt;std_msgs::msg::Float64MultiArray&gt;::SharedPtr subscription_desired_joint_accelerations_;\n        rclcpp::Publisher&lt;std_msgs::msg::Float64MultiArray&gt;::SharedPtr publisher_joint_torques_;\n        rclcpp::TimerBase::SharedPtr timer_;\n\n        // Joint variables\n        Eigen::VectorXd joint_positions_;\n        Eigen::VectorXd joint_velocities_;\n        Eigen::VectorXd desired_joint_accelerations_;\n        Eigen::VectorXd joint_torques_;\n\n        // dynamic parameters variables\n        double m1_;\n        double m2_;\n        double l1_;\n        double l2_;\n        double b1_;\n        double b2_;\n        double g_;\n    };\n\n    int main(int argc, char *argv[])\n    {\n        rclcpp::init(argc, argv);\n        auto node = std::make_shared&lt;DynamicsCancellationNode&gt;();\n        rclcpp::spin(node);\n        rclcpp::shutdown();\n        return 0;\n    }\n</code></pre> <ol> <li>You need to program the method <code>cancel_dynamics()</code> to calculate de desired torques.     <pre><code>// Method to calculate the desired joint torques\nEigen::VectorXd cancel_dynamics()\n{\n     // Initialize M, C, Fb, g_vec, and tau_ext\n\n    // Initialize q1, q2, q_dot1, and q_dot2\n\n    // Calculate matrix M\n\n    // Calculate vector C (C is 2x1 because it already includes q_dot)\n\n    // Calculate Fb matrix\n\n    // Calculate g_vect\n\n    // Calculate control torque using the dynamic model: torque = M * q_ddot + C * q_dot + Fb * q_dot + g\n    Eigen::VectorXd torque(2);\n    torque &lt;&lt; 0, 0;\n\n    return torque;\n}\n</code></pre></li> <li>Create the <code>dynamics_cancellation_launch.py</code> file (you need to do this in order to get the dynamic pameters from the config file). You don't need to do any modification in this file, just include it inside the launch folder.      Show the code dynamics_cancellation_launch.py<pre><code>    import os\n    from launch import LaunchDescription\n    from launch_ros.actions import Node\n    from ament_index_python.packages import get_package_share_directory\n\n    def generate_launch_description():\n        config = os.path.join(\n            get_package_share_directory('uma_arm_control'),\n            'config',\n            'dynamics_params.yaml'\n        )\n\n        dynamics_cancellation_node = Node(\n                package='uma_arm_control',\n                executable='dynamics_cancellation',\n                name='dynamics_cancellation',\n                output='screen',\n                parameters=[config]\n            )\n\n        return LaunchDescription([dynamics_cancellation_node])\n</code></pre> </li> <li>Modify the <code>CMakeLists.txt</code> to include the new node      Show the code CMakeLists.txt<pre><code>    #   Author: Juan M. Gandarias (http://jmgandarias.com)\n    #   email: jmgandarias@uma.es\n\n    cmake_minimum_required(VERSION 3.8)\n    project(uma_arm_control)\n\n    if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n      add_compile_options(-Wall -Wextra -Wpedantic)\n    endif()\n\n    # find dependencies\n    find_package(ament_cmake REQUIRED)\n    find_package(rclcpp REQUIRED)\n    find_package(std_msgs REQUIRED)\n    find_package(geometry_msgs REQUIRED)\n    find_package(sensor_msgs REQUIRED)\n    find_package(Eigen3 REQUIRED)\n\n    include_directories(${EIGEN3_INCLUDE_DIR})\n\n    ## COMPILE\n    add_executable(uma_arm_dynamics src/uma_arm_dynamics.cpp)\n    add_executable(gravity_compensation src/gravity_compensation.cpp)\n    add_executable(dynamics_cancellation src/dynamics_cancellation.cpp)\n\n    ament_target_dependencies(uma_arm_dynamics \n      rclcpp\n      std_msgs\n      sensor_msgs\n      geometry_msgs\n      Eigen3\n    )\n\n    ament_target_dependencies(gravity_compensation \n      rclcpp\n      std_msgs\n      sensor_msgs\n      Eigen3\n    )\n\n    ament_target_dependencies(dynamics_cancellation \n      rclcpp\n      std_msgs\n      sensor_msgs\n      geometry_msgs\n      Eigen3\n    )\n\n    if(BUILD_TESTING)\n      find_package(ament_lint_auto REQUIRED)\n      # the following line skips the linter which checks for copyrights\n      # comment the line when a copyright and license is added to all source files\n      set(ament_cmake_copyright_FOUND TRUE)\n      # the following line skips cpplint (only works in a git repo)\n      # comment the line when this package is in a git repo and when\n      # a copyright and license is added to all source files\n      set(ament_cmake_cpplint_FOUND TRUE)\n      ament_lint_auto_find_test_dependencies()\n    endif()\n\n    install(TARGETS uma_arm_dynamics dynamics_cancellation gravity_compensation\n      DESTINATION lib/${PROJECT_NAME}\n      )\n\n    install(DIRECTORY \n      launch\n      config\n      DESTINATION share/${PROJECT_NAME}/\n    )\n\n    ament_package()\n</code></pre> </li> <li> <p>Once you have done this, the uma_arm_control package should look like this:</p> <p></p> </li> <li> <p>Now, you can compile the workspace     </p><pre><code>cdw\ncb\n</code></pre> </li> </ol>"},{"location":"lab3/#322-launch-the-controller","title":"3.2.2. Launch the controller","text":"<p>To launch the inverse dynamics controller you'll need to do the following:</p> <ol> <li>Open one terminal and launch the uma_arm_visualization.</li> <li>Open another terminal and launch the controller.</li> <li>Open another terminal and launch the dynamics model.</li> </ol>"},{"location":"lab3/#322-expected-results","title":"3.2.2. Expected results","text":"<p>If the inverse dynamics controller works well, when a trajectory is commanded to the controller, the manipulator should exactly follow that trajectory.  We can test it by sending a cubic joint trajectory. To do this, the <code>uma_arm_control</code> package provides a cubic trajectory generator you can use.</p> <p>You can generate the desired joint trajectory by openning a new terminal and running the following:</p> <pre><code>cdw\ncd src/uma_arm_control/utils\npython3 cubic_trajectory.py\n</code></pre> <p>Once you have done this, your rqt_graph should then look like this:</p> <p></p> <p>If you record the data of the experiment, you'll see the following:</p> <p></p>"},{"location":"lab3/#33-experiments","title":"3.3. Experiments","text":"<p>Question</p> <ul> <li> <p>What happens if the compensation dynamics model is not exactly the same as the manipulator dynamics? </p> <ol> <li>Try to change the masses <code>m1</code>, <code>m2</code> and lengths <code>l1</code>, <code>l2</code> of the links in the <code>dynamics_params.yaml</code> (gravity_compensation) file. What are the effects of having incorrent dynamics parameters when launching the gravity compensation controller?</li> <li>Try the same for the dynamics cancellation. In this case, you can also change the parameters <code>b1</code> and <code>b2</code>. What are the effects when launching the dynamics cancellation controller?</li> </ol> </li> <li> <p>What is the behavior of the robot under the inverse dynamics controller when you apply virtual forces to the EE? Use videos and/or plots to support your answer.</p> </li> </ul>"},{"location":"lab3/#34-extra-optional","title":"3.4. Extra (optional)","text":"<p>Create a node that implements the PD controller presented in Fig. 4 (stabilizing linear control block) of the lecture slides. Specify a desired joint position \\(\\mathbf{q}_d\\) (inside the joint workspace) and set \\(\\dot{\\mathbf{q}}_d = \\boldsymbol{0}\\), \\(\\ddot{\\mathbf{q}}_d = \\boldsymbol{0}\\). </p> <p>This node must subscribe to the current joint state topic <code>/joint_states</code> to get the current joint positions (\\(\\mathbf{q}\\)) and velocities (\\(\\dot{\\mathbf{q}}\\)); and it must then publish the desired joint accelerations (\\(\\ddot{\\mathbf{q}}_d\\)) in the topic <code>/desired_joint_accelerations</code> to which the dynamics cancellation node will subscribe.</p> <p>Select and report the values chosen for \\(\\mathbf{K}_P\\) and \\(\\mathbf{K}_D\\). You can use matlab to simulate the expected dynamic behavior of the overall system. </p>"},{"location":"lab4/","title":"Lab Session 4: Impedance Control","text":""},{"location":"lab4/#lab-session-4-impedance-control","title":"Lab Session 4: Impedance Control","text":""},{"location":"lab4/#41-cartesian-impedance-control","title":"4.1. Cartesian impedance control","text":"<p>In this lab session we are going to implement a Cartesian Impedance Controller. </p> <p>The controller will be implemented according to the following scheme</p> <p></p>"},{"location":"lab4/#42-controller-implementation","title":"4.2. Controller implementation","text":"<p>To implement the impedance controller following the previous control scheme, you need to create a new node called impedance_controller.cpp.</p> <p>This script computes the dynamic model of a RR manipulator according to the impedance model:</p> <p>F_ext - k x_error - B x'_error = M x''</p> <p>where x_error = x_d - x, and x'_error = x'_d - x'</p> <p>then: x'' = M^(-1)[F_ext - k x_error - B x'_error]</p> <ul> <li>To compute x_error and x'_error, we need the current x and x'. They can be computed with the forward kinematics model and first-order differential kinematics:</li> </ul> <p>Forward kinematics: x  =  f(q) First-order differential kinematics: x' = J(q) q'</p> <ul> <li> <p>We assume F_ext is given from the measures of an F/T sensor in the EE.</p> </li> <li> <p>The computed x'' represents the desired dynamic behavior of the manipulator at the EE level, but it must be transformed to the joint space. It can be done with the second order differential kinematics (deriving the first-order kinematics):</p> </li> </ul> <p>First-order differential kinematics:   q'  = J(q)^(-1) x' Second-order differential kinematics:  q'' = J(q)^(-1)[x'' - J'(q',q)q']</p>"},{"location":"lab4/#43-experiment-1","title":"4.3. Experiment 1:","text":"<p>Question</p> <ul> <li>Does the forces applied in axis X generate motions in axis Y? And does the forces applied in axis Y generate motions in axis X? </li> <li>Can you explain why applying forces in one axis generate motions in the other axis? </li> <li>How do you think this phenomena can be reduced/mitigated?</li> </ul> <p>Question</p> <ul> <li>What are the effects of changing the impedance parameters (<code>M</code>, <code>B</code>, <code>K</code>) in the <code>impedance_params.yaml</code> file?</li> <li>What are the effects of having a \"high impedance\" in axis X and \"low impedance\" in axis Y?</li> </ul>"},{"location":"lab4/#44-experiment-2","title":"4.4. Experiment 2:","text":"<p>Question</p> <ul> <li> <p>Play with the simulation by publishing different desired equilibrium poses. Test the simulation to the extreme by taking the robot to difficult joint configurations. Don't worry about the robot, it's just a simulation and it won't break :) </p> </li> <li> <p>Did you find that the robot makes strange or unwanted motions, can you report them and explain why it happens?</p> </li> </ul>"},{"location":"lab5/","title":"Lab Session 5: Admittance controller","text":"<p>TBD</p>"},{"location":"lab6/","title":"Lab Session 6: Force control with inner position loop","text":"<p>TBD</p>"}]}